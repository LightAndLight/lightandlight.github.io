<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/fonts/SourceSerif4/SourceSerif4-Regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/SourceSans3/SourceSans3-Regular.woff2" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href="/res/fonts.css">
  <link rel="stylesheet" href="/res/style.css">

  <!-- defer non-critical stylesheet -->
  <link href="/res/syntax.css" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/res/syntax.css"></noscript>

  

  

  

  
  <title>Introduction to Unification - blog.ielliott.io</title>
  

  <link rel="canonical" href="https://blog.ielliott.io/introduction-to-unification">
<link rel="alternate" type="application/atom+xml" title="blog.ielliott.io" href="/feed.xml">

<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="blog.ielliott.io">
<meta property="og:url" content="https://blog.ielliott.io/introduction-to-unification">
<meta property="og:title" content="Introduction to Unification">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Introduction to Unification">


<meta name="author" content="Isaac Elliott">
<meta name="description" content="Unification is a vital process in the implementation of Hindley-Damas-Milner
type inference. In the original paper
it is mentioned in passing as assumed knowledge, so here is an explanation of
unification in with a little help from the HM type theory.">
<meta property="og:description" content="Unification is a vital process in the implementation of Hindley-Damas-Milner
type inference. In the original paper
it is mentioned in passing as assumed knowledge, so here is an explanation of
unification in with a little help from the HM type theory.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-01-07T00:00+00:00">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline":"Introduction to Unification",
  "author": {
    "@type":"Person",
    "name":"Isaac Elliott"
  },
  "datePublished":"2017-01-07T00:00+00:00",
  "dateModified":"2017-01-07T00:00+00:00",
  "description":"Unification is a vital process in the implementation of Hindley-Damas-Milner
type inference. In the original paper
it is mentioned in passing as assumed knowledge, so here is an explanation of
unification in with a little help from the HM type theory.",
  "mainEntityOfPage": {
    "@type":"WebPage",
    "@id":"https://blog.ielliott.io/introduction-to-unification"
  },
  "url": "https://blog.ielliott.io/introduction-to-unification"
}
</script>
</head>

<body>
  <header>
    <h1><a href="/">I E</a></h1>
    <nav>
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/about">About</a>
        <li><a href="/resources">Resources</a>
      </ol>
    </nav>
  </header>

  <main>
    

    <article>
  <header>
    <h1>Introduction to Unification</h1>
    <p class="post-metadata">
       7 January, 2017
      
    </p>
  </header>
  <p>Unification is a vital process in the implementation of Hindley-Damas-Milner
type inference. In the <a href="http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf">original paper</a>
it is mentioned in passing as assumed knowledge, so here is an explanation of
unification in with a little help from the HM type theory.</p>
<h2 id="what-is-unification"><a href="#what-is-unification">What is Unification?</a></h2>
<p>Unification is a method of solving equations by substitution. This sentence alone
doesn’t give enough information to implement an algorithm, so let’s define some
vocabulary to write a more rigorous definition.</p>
<p><code>term</code>: A term is an abstract syntax tree representing the language that will be used.
In order for unification to proceed, term must have some value that represents a
<code>variable</code>, and some values that represent <code>constants</code>- the idea being that <code>variables</code>
can be replaced during unification, but constants cannot.</p>
<p><code>equation</code>: An equation is a pair of terms, written <code>term_1 = term_2</code>.</p>
<p><code>syntactic equality</code>: Two terms are syntactically equal if their ASTs match
exactly.</p>
<p><code>equivalence</code>: Two terms are equivalent if there exists some substitution that would
make them syntactically equal.</p>
<p><code>solved</code>: An equation is solved if the left and right hand sides are syntactically
equal.</p>
<p><code>substitution</code>: A substitution is a set of mappings from variables to terms, written
<code>{ var_1 =&gt; term_1, ..., var_i =&gt; term_i }</code>.</p>
<p><code>application</code>: A substitution can be <code>applied</code> to a value containing variables - written <code>subs(value)</code>:</p>
<ul>
<li>term: by replacing variables with terms per each mapping</li>
<li>equation: by applying the substitution to both sides</li>
<li>set of equations: by applying the substitution to each element in the set</li>
<li>substitution: by applying the substitution to the right hand side of each mapping</li>
</ul>
<p>Applying an empty substitution to a value does not change the value.
For reasons that will be explained later, a substitution is only valid if every
variable on the left side of mapping does <em>not</em> occur in the term on the right
side of the respective mapping.</p>
<p><code>minimal</code>: A substitution is minimal if no variables in the right hand sides of
any mapping occur on any left hand side of any mapping. In other words, if
applying the substitution is idempotent: <code>subs(subs(value)) = subs(value)</code></p>
<p>With this vocabulary, we can now better define unification:</p>
<p><em>Given a set of equations <code>eqs</code>, find a minimal substitution <code>sub</code> such that
every equation in <code>sub(eqs)</code> is solved</em></p>
<h2 id="hindley-milner"><a href="#hindley-milner">Hindley-Milner</a></h2>
<p>Unification is the backbone of type inference in the HM type theory. The actual
type inference algorithm is not important here- just how unification works on
HM terms.</p>
<p>A term in HM is defined as <code>term := term -&gt; term | primitive | variable</code> where
<code>primitive</code> is an element of a set of primitive types and <code>variable</code> is a string.
respectively. To satisfy the requirements of unification, primitives are constants
and variables are, of course, variables.</p>
<p>Examples of syntactically equal HM terms:</p>
<ul>
<li><code>a</code> and <code>a</code></li>
<li><code>primitive</code> and <code>primitive</code></li>
<li><code>a -&gt; a</code> and <code>a -&gt; a</code></li>
</ul>
<p>Examples of equivalent HM terms:</p>
<ul>
<li><code>a</code> and <code>c</code></li>
<li><code>primitive</code> and <code>d</code></li>
<li><code>(a -&gt; b) -&gt; c</code> and <code>d -&gt; e</code></li>
</ul>
<p>When conducting type inference for an expression, its type is initially set to a
new variable. A set of equations is generated by traversing the expression’s AST,
then these equations are then unified, which yields a solution for the
expression’s type variable.</p>
<h2 id="an-algorithm"><a href="#an-algorithm">An Algorithm</a></h2>
<p>A simple unification algorithm can be described as follows:</p>
<pre><code>unify(equations):
  solutions := {}
  ix := 0
  while ix &lt; equations.length:
    equation := equations[ix]
    if solved(equation):
      ix++
      continue

    substitution := {}  
    if is_variable(equation.lhs):
      if occurs(equation.lhs, equation.rhs):
        error(&quot;Variable occurred on both sides of an equation&quot;)
      substitution := {current.lhs =&gt; current.rhs}
      ix++
    elif is_variable(equation.rhs):
      swap_sides(equations[ix])
    elif equivalent(equation.lhs, equation.rhs):
      substitution := unify(implied_equations(equation))
    else:
      error(&quot;Cannot unify non-equivalent terms&quot;)

    substitution.apply(solutions)
    substitution.apply(equations)
    solutions.union(substitution)

  return solutions</code></pre>
<p>In essence the algorithm is “rearrange an equation so it is a solution, update
everything according to this knowledge, remember the solution and continue”.
<a href="https://en.wikipedia.org/wiki/System_of_linear_equations#Elimination_of_variables">Sounds like something we did a lot in school…</a></p>
<h3 id="why-check-occurs"><a href="#why-check-occurs">Why check <code>occurs</code>?</a></h3>
<p>This algorithm requires a substitution to ‘eliminate’ a variable from the problem.
If a variable could also be on the right side of a substitution then it would
not be eliminated, constructing an infinite solution.</p>
<p>To demonstrate, let’s unify the HM equations <code>{a = b -&gt; c, a = d, b = d, a = c}</code> without
the occurs check:</p>
<pre><code>equations = {a = b -&gt; c, a = d, b = d, a = c}
solutions = {}

equations = {b -&gt; c = d, b = d, b -&gt; c = c} (removed a = b -&gt; c, applied a =&gt; b -&gt; c)
solutions = {a =&gt; b -&gt; c} (added a =&gt; b -&gt; c)

equations = {b = b -&gt; c, b -&gt; c = c} (removed b -&gt; c = d, applied d = b -&gt; c)
solutions = {a =&gt; b -&gt; c, d =&gt; b -&gt; c} (added d =&gt; b -&gt; c)

equations = {(b -&gt; c) -&gt; c = c} (removed b = b -&gt; c, applied b = b -&gt; c)
solutions = {a =&gt; (b -&gt; c) -&gt; c, d =&gt; (b -&gt; c) -&gt; c, b =&gt; b -&gt; c} (applied then added b =&gt; b -&gt; c)

equations = {}
solutions = {a =&gt; (b -&gt; (b -&gt; c) -&gt; c) -&gt; c, d =&gt; (b -&gt; (b -&gt; c) -&gt; c) -&gt; (b -&gt; c) -&gt; c, b =&gt; b -&gt; (b -&gt; c) -&gt; c, c = (b -&gt; c) -&gt; c} (applied then added c =&gt; (b -&gt; c) -&gt; c)

apply solutions to original equations - remember that the solutions should solve all the original equations:

a = b -&gt; c
b -&gt; (b -&gt; c) -&gt; c = b -&gt; c (using a =&gt; ...)
b -&gt; (b -&gt; (b -&gt; c) -&gt; c) -&gt; (b -&gt; c) -&gt; c = b -&gt; (b -&gt; c) -&gt; c (using c =&gt; ...)

no matter how many times we do this the equation will never be solved...</code></pre>
<p>Omitting the occurs check does <em>not</em> unify the equations according our definition.</p>
<h2 id="resources"><a href="#resources">Resources</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">Wikipedia entry for Unification</a>
is amazing and goes into much more depth.</p>
  <p class="post-navigation">
  
  <a href="/why-LINQ-is-broken" title="Previous post: Why LINQ (well, C#) is Broken">← Why LINQ (well, C#) is Broken</a>
  

  
  <a href="/how-to-delete-old-nixos-boot-configurations" title="Next post: How to delete old NixOS boot configurations">How to delete old NixOS boot configurations →</a>
  
</p>

</article>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'ielliott'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

  </main>

  <footer>
    <span>Isaac Elliott</span>

    <ol>
      <li><a class="footer-item-link" href="https://github.com/lightandlight">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M208.31 75.68A59.78 59.78 0 0 0 202.93 28a8 8 0 0 0-6.93-4 59.75 59.75 0 0 0-48 24h-24a59.75 59.75 0 0 0-48-24 8 8 0 0 0-6.93 4 59.78 59.78 0 0 0-5.38 47.68A58.14 58.14 0 0 0 56 104v8a56.06 56.06 0 0 0 48.44 55.47A39.8 39.8 0 0 0 96 192v8H72a24 24 0 0 1-24-24 40 40 0 0 0-40-40 8 8 0 0 0 0 16 24 24 0 0 1 24 24 40 40 0 0 0 40 40h24v16a8 8 0 0 0 16 0v-40a24 24 0 0 1 48 0v40a8 8 0 0 0 16 0v-40a39.8 39.8 0 0 0-8.44-24.53A56.06 56.06 0 0 0 216 112v-8a58.14 58.14 0 0 0-7.69-28.32M200 112a40 40 0 0 1-40 40h-48a40 40 0 0 1-40-40v-8a41.74 41.74 0 0 1 6.9-22.48 8 8 0 0 0 1.1-7.69 43.8 43.8 0 0 1 .79-33.58 43.88 43.88 0 0 1 32.32 20.06 8 8 0 0 0 6.71 3.69h32.35a8 8 0 0 0 6.74-3.69 43.87 43.87 0 0 1 32.32-20.06 43.8 43.8 0 0 1 .77 33.58 8.09 8.09 0 0 0 1 7.65 41.7 41.7 0 0 1 7 22.52Z"></path></svg>
        GitHub
      </a>

      <li><a class="footer-item-link" href="mailto:blog@id.ielliott.io">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 48H32a8 8 0 0 0-8 8v136a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a8 8 0 0 0-8-8m-20.57 16L128 133.15 52.57 64ZM216 192H40V74.19l82.59 75.71a8 8 0 0 0 10.82 0L216 74.19z"></path></svg>
        Email
      </a>

      <li><a class="footer-item-link" href="https://blog.ielliott.io/feed.xml">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 192a8 8 0 0 1-16 0c0-79.4-64.6-144-144-144a8 8 0 0 1 0-16c88.22 0 160 71.78 160 160M64 104a8 8 0 0 0 0 16 72.08 72.08 0 0 1 72 72 8 8 0 0 0 16 0 88.1 88.1 0 0 0-88-88m4 72a12 12 0 1 0 12 12 12 12 0 0 0-12-12"></path></svg>
        Feed
      </a>
    </ol>
  </footer>

  
</body>

</html>