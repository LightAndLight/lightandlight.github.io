<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/fonts/SourceSerif4/SourceSerif4-Regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/SourceSans3/SourceSans3-Regular.woff2" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href="/res/fonts.css">
  <link rel="stylesheet" href="/res/style.css">

  <!-- defer non-critical stylesheet -->
  <link href="/res/syntax.css" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/res/syntax.css"></noscript>

  

  

  

  
  <title>An Example of Defunctionalisation in Rust - blog.ielliott.io</title>
  

  <link rel="canonical" href="https://blog.ielliott.io/rust-defun-example">
<link rel="alternate" type="application/atom+xml" title="blog.ielliott.io" href="/feed.xml">

<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="blog.ielliott.io">
<meta property="og:url" content="https://blog.ielliott.io/rust-defun-example">
<meta property="og:title" content="An Example of Defunctionalisation in Rust">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="An Example of Defunctionalisation in Rust">


<meta name="author" content="Isaac Elliott">
<meta name="description" content="I'm an experienced Haskell programmer, and I've been writing a lot of Rust lately.
I recently ran into a little trouble when porting a simple function from Haskell to
Rust. This article is a short description of my journey.">
<meta property="og:description" content="I'm an experienced Haskell programmer, and I've been writing a lot of Rust lately.
I recently ran into a little trouble when porting a simple function from Haskell to
Rust. This article is a short description of my journey.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-02-06T00:00+00:00">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline":"An Example of Defunctionalisation in Rust",
  "author": {
    "@type":"Person",
    "name":"Isaac Elliott"
  },
  "datePublished":"2021-02-06T00:00+00:00",
  "dateModified":"2021-02-06T00:00+00:00",
  "description":"I'm an experienced Haskell programmer, and I've been writing a lot of Rust lately.
I recently ran into a little trouble when porting a simple function from Haskell to
Rust. This article is a short description of my journey.",
  "mainEntityOfPage": {
    "@type":"WebPage",
    "@id":"https://blog.ielliott.io/rust-defun-example"
  },
  "url": "https://blog.ielliott.io/rust-defun-example"
}
</script>
</head>

<body>
  <header>
    <h1><a href="/">I E</a></h1>
    <nav>
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/about">About</a>
        <li><a href="/resources">Resources</a>
      </ol>
    </nav>
  </header>

  <main>
    

    <article>
  <header>
    <h1>An Example of Defunctionalisation in Rust</h1>
    <p class="post-metadata">
       6 February, 2021
      
      ⋅
      
<a class="post-metadata-tag" href="/tags/programming">programming</a>


      
    </p>
  </header>
  <p>I’m an experienced Haskell programmer, and I’ve been writing a lot of Rust lately.
I recently ran into a little trouble when porting a simple function from Haskell to
Rust. This article is a short description of my journey.</p>
<hr />
<p><a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn indexed</a> terms are
<a href="https://en.wikipedia.org/wiki/Functor">functorial</a> in their free variables.
This means that given a datatype <code>Expr</code>, we can write a function
<code>map_freevars : (Int -&gt; Int) -&gt; Expr -&gt; Expr</code> such that <code>map_freevars id == id</code>
and <code>map_freevars f ∘ map_freevars g == map_freevars (f ∘ g)</code>. In Haskell, I’d
implement this as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">map_freevars ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>map_freevars f e <span class="ot">=</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Var</span> n <span class="ot">-&gt;</span> <span class="dt">Var</span> (f n)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">App</span> a b <span class="ot">-&gt;</span> <span class="dt">App</span> (map_freevars f a) (map_freevars f b)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lam</span> b <span class="ot">-&gt;</span> <span class="dt">Lam</span> (map_freevars (\n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span> <span class="op">+</span> f (n <span class="op">-</span> <span class="dv">1</span>)) b)</span></code></pre></div>
<p>Now, here’s a direct translation from Haskell to Rust:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Expr <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    Var(<span class="dt">usize</span>)<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    App(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    Lam(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> map_freevars<span class="op">&lt;</span>F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span>(f<span class="op">:</span> F<span class="op">,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Var(n) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(f(<span class="op">*</span>n))<span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>App(a<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> a))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> b)))<span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Lam(b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span>n<span class="op">|</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">0</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">1</span> <span class="op">+</span> f(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            b</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        )))<span class="op">,</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This doesn’t typecheck because the call to <code>map_freevars(f, a)</code> takes ownership of <code>f</code>,
which means <code>f</code> can no longer be used in the call to <code>map_freevars(f, b)</code>.</p>
<p>To avoid this, <code>map_freevars</code> should <em>borrow</em> the mapping function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> map_freevars<span class="op">&lt;</span>F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span>(f<span class="op">:</span> <span class="op">&amp;</span>F<span class="op">,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Var(n) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(f(<span class="op">*</span>n))<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>App(a<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> a))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> b)))<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Lam(b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;|</span>n<span class="op">|</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">1</span> <span class="op">+</span> f(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            b</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        )))<span class="op">,</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But this doesn’t compile either! The Rust compiler reports
that it <code>reached the recursion limit while instantiating map_freevars::&lt;[closure@...]&gt;</code>.
Rust generates all its closures at compile time, and this code causes the compiler to
generate a countably infinite number of closures.</p>
<p>For every known closure that is passed to <code>map_freevars</code> as <code>f</code>, Rust generates another
closure for <code>|n| if n == 0 { 0 } else { 1 + f(n - 1) } }</code>. But <code>|n| if n == 0 { 0 } else { 1 + f(n - 1) } }</code>
is also passed to <code>map_freevars</code>, so another closure needs to be generated. And <em>that</em> closure is
also passed to <code>map_freevars</code>, so another closure needs to be generated. And so on.</p>
<p>The next natural step is to use a <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait object</a>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> map_freevars(f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Var(n) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(f(<span class="op">*</span>n))<span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>App(a<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> a))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> b)))<span class="op">,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Lam(b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;|</span>n<span class="op">|</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">1</span> <span class="op">+</span> f(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            b</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        )))<span class="op">,</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A <code>&amp;dyn</code> reference is a pair of pointers; one pointer to a value of a type that implements the trait,
and another pointer to the implementation of the trait for that type<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>This code is perfectly usable, and I’d guess it’s the ‘idiomatic’ Rust solution. But there’s one final
step I’d like to take, mostly for educational perposes, and for a small efficiency gain.</p>
<p>For all intents and purposes, there are only two possible ‘origins’ for <code>f</code>:</p>
<ol type="1">
<li>It was passed to <code>map_freevars</code> unchanged, either from a top-level call or from a recursive call at an
<code>App</code> node</li>
<li>It was wrapped in a closure before being passed to <code>map_freevars</code> at a <code>Lam</code> node</li>
</ol>
<p>This structure is described by the following datatype:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Origin<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Unchanged(F)<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    LamNode(<span class="op">&amp;</span><span class="ot">'a</span> Origin<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">&gt;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>Origin</code> datatype can be interpreted as a function from <code>usize</code> to <code>usize</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span> Origin<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> apply(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> n<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Origin::</span>Unchanged(f) <span class="op">=&gt;</span> f(n)<span class="op">,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Origin::</span>LamNode(f) <span class="op">=&gt;</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span> <span class="dv">0</span> <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="dv">1</span> <span class="op">+</span> f<span class="op">.</span>apply(n<span class="op">-</span><span class="dv">1</span>) <span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>Challenge: implement <code>Origin::apply</code> using constant stack space.</em></p>
<p>Now the <code>Origin::LamNode</code> constructor replaces the fresh closure in the <code>Lam</code> branch:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> map_freevars<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span>(f<span class="op">:</span> <span class="op">&amp;</span><span class="ot">'a</span> Origin<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">&gt;,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Var(n) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(f<span class="op">.</span>apply(<span class="op">*</span>n))<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>App(a<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> a))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(map_freevars(f<span class="op">,</span> b)))<span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Lam(b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(<span class="dt">Box</span><span class="pp">::</span>new(map_freevars(<span class="op">&amp;</span><span class="pp">Origin::</span>LamNode(f))))<span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This transformation is an example of <a href="https://en.wikipedia.org/wiki/Defunctionalization">defunctionalisation</a>.</p>
<p>Here, the practical benefit is that <code>&amp;Origin</code> is half the size of a <code>&amp;dyn Fn(usize) -&gt; usize</code> (a single pointer
instead of two), so recursing over a <code>Lam</code> node uses less stack space.</p>
<p>The interface to <code>map_freevars</code> can then be cleaned up using the worker/wrapper pattern:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> map_freevars<span class="op">&lt;</span>F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span>(f<span class="op">:</span> F<span class="op">,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> go<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">&gt;</span>(f<span class="op">:</span> <span class="op">&amp;</span><span class="ot">'a</span> Origin<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> F<span class="op">&gt;,</span> e<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> Expr <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Expr::</span>Var(n) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(f<span class="op">.</span>apply(<span class="op">*</span>n))<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Expr::</span>App(a<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(<span class="dt">Box</span><span class="pp">::</span>new(go(f<span class="op">,</span> a))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(go(f<span class="op">,</span> b)))<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Expr::</span>Lam(b) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(<span class="dt">Box</span><span class="pp">::</span>new(go(<span class="op">&amp;</span><span class="pp">Origin::</span>LamNode(f))))<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    go(<span class="op">&amp;</span><span class="pp">Origin::</span>Unchanged(f)<span class="op">,</span> e)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p>I haven’t benchmarked the defunctionalised approach and compared it against the trait object
implementation. If anyone has suggestions for easily measuring the time and memory usage of
Rust programs, preferably by function, then please let me know.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is a form of existential quantification. The Haskell equivalent looks something like
<code>data Some (c :: Constraint) where; Some :: c a =&gt; a -&gt; Some c</code><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  <p class="post-navigation">
  
  <a href="/docker-cleanup-commands" title="Previous post: Docker Cleanup Commands">← Docker Cleanup Commands</a>
  

  
  <a href="/webgl-slower-than-canvas" title="Next post: WebGL Slower Than Canvas?">WebGL Slower Than Canvas? →</a>
  
</p>

</article>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'ielliott'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

  </main>

  <footer>
    <span>Isaac Elliott</span>

    <ol>
      <li><a class="footer-item-link" href="https://github.com/lightandlight">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M208.31 75.68A59.78 59.78 0 0 0 202.93 28a8 8 0 0 0-6.93-4 59.75 59.75 0 0 0-48 24h-24a59.75 59.75 0 0 0-48-24 8 8 0 0 0-6.93 4 59.78 59.78 0 0 0-5.38 47.68A58.14 58.14 0 0 0 56 104v8a56.06 56.06 0 0 0 48.44 55.47A39.8 39.8 0 0 0 96 192v8H72a24 24 0 0 1-24-24 40 40 0 0 0-40-40 8 8 0 0 0 0 16 24 24 0 0 1 24 24 40 40 0 0 0 40 40h24v16a8 8 0 0 0 16 0v-40a24 24 0 0 1 48 0v40a8 8 0 0 0 16 0v-40a39.8 39.8 0 0 0-8.44-24.53A56.06 56.06 0 0 0 216 112v-8a58.14 58.14 0 0 0-7.69-28.32M200 112a40 40 0 0 1-40 40h-48a40 40 0 0 1-40-40v-8a41.74 41.74 0 0 1 6.9-22.48 8 8 0 0 0 1.1-7.69 43.8 43.8 0 0 1 .79-33.58 43.88 43.88 0 0 1 32.32 20.06 8 8 0 0 0 6.71 3.69h32.35a8 8 0 0 0 6.74-3.69 43.87 43.87 0 0 1 32.32-20.06 43.8 43.8 0 0 1 .77 33.58 8.09 8.09 0 0 0 1 7.65 41.7 41.7 0 0 1 7 22.52Z"></path></svg>
        GitHub
      </a>

      <li><a class="footer-item-link" href="mailto:blog@id.ielliott.io">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 48H32a8 8 0 0 0-8 8v136a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a8 8 0 0 0-8-8m-20.57 16L128 133.15 52.57 64ZM216 192H40V74.19l82.59 75.71a8 8 0 0 0 10.82 0L216 74.19z"></path></svg>
        Email
      </a>

      <li><a class="footer-item-link" href="/feed.xml">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 192a8 8 0 0 1-16 0c0-79.4-64.6-144-144-144a8 8 0 0 1 0-16c88.22 0 160 71.78 160 160M64 104a8 8 0 0 0 0 16 72.08 72.08 0 0 1 72 72 8 8 0 0 0 16 0 88.1 88.1 0 0 0-88-88m4 72a12 12 0 1 0 12 12 12 12 0 0 0-12-12"></path></svg>
        Feed
      </a>
    </ol>
  </footer>

  
</body>

</html>
