<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/fonts/SourceSerif4/SourceSerif4-Regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/SourceSans3/SourceSans3-Regular.woff2" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href="/res/fonts.css">
  <link rel="stylesheet" href="/res/style.css">

  <!-- defer non-critical stylesheet -->
  <link href="/res/syntax.css" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/res/syntax.css"></noscript>

  

  

  

  
  <title>Statically Sized Higher-kinded Polymorphism - blog.ielliott.io</title>
  

  <link rel="canonical" href="https://blog.ielliott.io/sized-hkts">
<link rel="alternate" type="application/atom+xml" title="blog.ielliott.io" href="/feed.xml">

<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="blog.ielliott.io">
<meta property="og:url" content="https://blog.ielliott.io/sized-hkts">
<meta property="og:title" content="Statically Sized Higher-kinded Polymorphism">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Statically Sized Higher-kinded Polymorphism">


<meta name="author" content="Isaac Elliott">
<meta name="description" content="Memory-sensitive languages like C++ and Rust use compile-time information to calculate
sizes of datatypes. These sizes are used to inform alignment, allocation, and calling conventions in ways
that improve runtime performance. Modern languages in this setting support generic types, but so far
these languages only allow parameterisation over types, not type constructors. In this article I describe
how to enable parameterisation over arbitrary type constructs, while still retaining compile-time calculation
of datatype sizes.">
<meta property="og:description" content="Memory-sensitive languages like C++ and Rust use compile-time information to calculate
sizes of datatypes. These sizes are used to inform alignment, allocation, and calling conventions in ways
that improve runtime performance. Modern languages in this setting support generic types, but so far
these languages only allow parameterisation over types, not type constructors. In this article I describe
how to enable parameterisation over arbitrary type constructs, while still retaining compile-time calculation
of datatype sizes.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-07-07T00:00+00:00">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline":"Statically Sized Higher-kinded Polymorphism",
  "author": {
    "@type":"Person",
    "name":"Isaac Elliott"
  },
  "datePublished":"2020-07-07T00:00+00:00",
  "dateModified":"2020-07-07T00:00+00:00",
  "description":"Memory-sensitive languages like C++ and Rust use compile-time information to calculate
sizes of datatypes. These sizes are used to inform alignment, allocation, and calling conventions in ways
that improve runtime performance. Modern languages in this setting support generic types, but so far
these languages only allow parameterisation over types, not type constructors. In this article I describe
how to enable parameterisation over arbitrary type constructs, while still retaining compile-time calculation
of datatype sizes.",
  "mainEntityOfPage": {
    "@type":"WebPage",
    "@id":"https://blog.ielliott.io/sized-hkts"
  },
  "url": "https://blog.ielliott.io/sized-hkts"
}
</script>
</head>

<body>
  <header>
    <h1><a href="/">I E</a></h1>
    <nav>
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/about">About</a>
        <li><a href="/resources">Resources</a>
      </ol>
    </nav>
  </header>

  <main>
    

    <article>
  <header>
    <h1>Statically Sized Higher-kinded Polymorphism</h1>
    <p class="post-metadata">
       7 July, 2020
      
      ⋅
      
<a class="post-metadata-tag" href="/tags/programming">programming</a>


      
    </p>
  </header>
  <div class="intro-wrapper">
<div class="intro">
<p>Memory-sensitive languages like C++ and Rust use compile-time information to calculate
sizes of datatypes. These sizes are used to inform alignment, allocation, and calling conventions in ways
that improve runtime performance. Modern languages in this setting support generic types, but so far
these languages only allow parameterisation over types, not type constructors. In this article I describe
how to enable parameterisation over arbitrary type constructs, while still retaining compile-time calculation
of datatype sizes.</p>
<p>The code for this project can be found <a href="https://github.com/LightAndLight/sized-hkts">here</a>.</p>
</div>
<div id="toc">
<h3>Contents</h3>
<ul>
<li><a href="#background">Background</a>
<ul>
<li><a href="#generics">Generics</a></li>
<li><a href="#sizing">Sizing</a></li>
<li><a href="#kinds">Kinds</a></li>
<li><a href="#type-classes">Type Classes</a></li>
<li><a href="#problem-statement">Problem Statement</a></li>
</ul></li>
<li><a href="#solution">Solution</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>
<h2 id="background"><a href="#background">Background</a></h2>
<h3 id="generics"><a href="#generics">Generics</a></h3>
<p>Many typed languages support some form of generic (parameterised) datatypes. This ability to abstract
over types is known as ‘parametric polymorphism’ (polymorphism for short). In Rust, for example, one
can define type of polymorphic pairs as <code>struct Pair&lt;A, B&gt;(fst: A, snd: B)</code>. In this definition, <code>A</code> and <code>B</code> are type
variables (or type parameters), and can be substituted for other types:
<code>Pair&lt;bool, bool&gt;</code>, <code>Pair&lt;bool, char&gt;</code>, and <code>Pair&lt;String, int32&gt;</code> are all valid pairs.</p>
<p>The name of a type, without any parameters, is known as a type constructor. <code>Pair</code> is not a type on its own;
<code>Pair&lt;A, B&gt;</code> (for some types <code>A</code> and <code>B</code>) is. The number of types required to ‘complete’ a type constructor is known
as its arity (so <code>Pair</code> has arity 2). The arity of a type constructor must always be respected; it’s an error to
provide greater or fewer type parameters than are expected. For example, <code>Pair&lt;bool&gt;</code> and
<code>Pair&lt;char, int32, String&gt;</code> are invalid.</p>
<h3 id="sizing"><a href="#sizing">Sizing</a></h3>
<p>When using C++ or Rust, the compiler will calculate how many bytes of memory each datatype requires. Simple
types like <code>int32</code> and <code>bool</code> have a constant size; 4 bytes and 1 byte respectively. The size of datatypes
built using of other simple types is easy to calculate. The simplest way to calculate the size of a struct
is to sum the sizes of the fields, and the simplest way to calculate the size of an enum (or tagged union)
is to find the largest variant, and add 1 (for a tag byte). This is rarely the exact formula used by production
compilers, because they take <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">alignment</a> into account.
This article will assume the simple sizing formula, because the results can easily be adapted to more nuanced
formulae.</p>
<p>The size of a datatype like <code>struct TwoInts(x: int32, y: int32)</code> is known immediately at its definition. <code>TwoInts</code>
requires 8 bytes of memory. On the other hand, the size of a generic datatype is not always known at its definition.
What is the size of <code>struct Pair&lt;A, B&gt;(fst: A, snd: B)</code>? It’s the size of <code>A</code> plus the size of <code>B</code>, for some
unknown <code>A</code> and <code>B</code>.</p>
<p>This difficulty is usually addressed by only generating code for datatypes and functions when all the generic
types have been replaced with concrete types. This process is known as monomorphisation. If the program contains a
<code>Pair(true, true)</code>, then the compiler will generate
a new type <code>struct PairBoolBool(fst: bool, snd: bool)</code> whose size is statically known. If <code>Pair(true, true)</code>
is passed to a function <code>fn swap&lt;A, B&gt;(p: Pair&lt;A, B&gt;) -&gt; Pair&lt;B, A&gt;</code>, then the compiler generates a new
function <code>fn swapBoolBool(p: PairBoolBool) -&gt; PairBoolBool</code>. Because this new function only uses types with known
sizes, the code for memory allocation and calling conventions can be generated correctly.</p>
<p>There are also generic types that <em>don’t</em> depend on the size of their parameters. An example of
this is the pointer, commonly known in Rust as <code>Box&lt;A&gt;</code>. A pointer has the same size (often 4 or 8 bytes depending
on your CPU) regardless of what it points to. But in order to allocate a new pointer, the size of the item must
be known.</p>
<p>For each generic datatype or function, the compiler keeps track of which type variables are important for sizing
calculations. The specifics of this is discussed in the <a href="#type-classes">Type Classes</a> section.</p>
<h3 id="kinds"><a href="#kinds">Kinds</a></h3>
<p>A consequence of all this is that in these languages, type variables can only stand for types. But there
are good reasons to have type variables that stand for type constructors, too:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> One<span class="op">&lt;</span>A<span class="op">&gt;</span>(A)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> One<span class="op">&lt;</span>A<span class="op">&gt;{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  map<span class="op">&lt;</span>B<span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(A) <span class="op">-&gt;</span> B<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> One<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Two<span class="op">&lt;</span>A<span class="op">&gt;</span>(A<span class="op">,</span> A)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> Two<span class="op">&lt;</span>A<span class="op">&gt;{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  map<span class="op">&lt;</span>B<span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(A) <span class="op">-&gt;</span> B<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> Two<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Three<span class="op">&lt;</span>A<span class="op">&gt;</span>(A<span class="op">,</span> A<span class="op">,</span> A)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> Three<span class="op">&lt;</span>A<span class="op">&gt;{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  map<span class="op">&lt;</span>B<span class="op">,</span> F<span class="op">:</span> <span class="bu">Fn</span>(A) <span class="op">-&gt;</span> B<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> Three<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here are some 1-arity container types. The only difference between these datatypes is the number of elements
they contain. They all support a <code>map</code> operation, which applies a function to all the datatype’s elements. Functions
that use <code>map</code> need to be implemented once for each type, even when their implementations are identical:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> incrOne(x<span class="op">:</span> One<span class="op">&lt;</span>int32<span class="op">&gt;</span>) <span class="op">-&gt;</span> One<span class="op">&lt;</span>int32<span class="op">&gt;</span> <span class="op">{</span> x<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="op">}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> incrTwo(x<span class="op">:</span> Two<span class="op">&lt;</span>int32<span class="op">&gt;</span>) <span class="op">-&gt;</span> Two<span class="op">&lt;</span>int32<span class="op">&gt;</span> <span class="op">{</span> x<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="op">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> incrThree(x<span class="op">:</span> Three<span class="op">&lt;</span>int32<span class="op">&gt;</span>) <span class="op">-&gt;</span> Three<span class="op">&lt;</span>int32<span class="op">&gt;</span> <span class="op">{</span> x<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="op">}</span></span></code></pre></div>
<p>To remedy this, there must first be a way to abstract over the type constructors, so that the code can
be written <em>once</em> and for all:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> incr<span class="op">&lt;</span>F<span class="op">&gt;</span>(x<span class="op">:</span> F<span class="op">&lt;</span>int32<span class="op">&gt;</span>) <span class="op">-&gt;</span> F<span class="op">&lt;</span>int32<span class="op">&gt;</span> <span class="op">{</span> x<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="op">}</span> <span class="co">// when F&lt;A&gt; has map, for all types A</span></span></code></pre></div>
<p>Then, there must be some way to rule out invalid types. For example, replacing <code>F</code> with <code>bool</code> in <code>F&lt;int32&gt;</code>
is invalid, because <code>bool&lt;int32&gt;</code> is not a type. This is the job of kinds<sup><a href="#reference-constructor-classes" id="reference-constructor-classes:1">1</a></sup>.</p>
<p>Kinds describe the ‘shape’ of types (and type constructors) in the same way that types describe the ‘shape’
of values. A type’s kind determines whether or not it takes any parameters. Here’s the syntax of kinds:</p>
<pre><code>kind ::=
  Type
  kind -&gt; kind</code></pre>
<p>Types that take no arguments (like <code>bool</code>, <code>char</code>, and <code>String</code>) have kind <code>Type</code>. Types that take one argument,
like <code>One</code>, have kind <code>Type -&gt; Type</code>. In the code for <code>incr</code> above, <code>F</code> implicitly has kind <code>Type -&gt; Type</code>. Types
that take more than one argument are represented in <a href="https://en.wikipedia.org/wiki/Currying">curried form</a>. This
means that <code>Two</code> has kind <code>Type -&gt; Type -&gt; Type</code>, not <code>(Type, Type) -&gt; Type</code>. <code>Three</code> has kind <code>Type -&gt; Type -&gt; Type -&gt; Type</code>,
and so on.</p>
<p>Curried type constructors are standard in this setting, but not <em>necessary</em>. The results in this article could
also be applied to a setting with uncurried type constructors, at cost to expressiveness or implementation complexity.</p>
<p>Kinds put types and type constructors on equal footing. For the remainder of the article, both concepts will be
referred to as types. The kind becomes the distinguishing feature. For example, “type constructor of arity 2” would
be replaced by “type of kind <code>Type -&gt; Type -&gt; Type</code>”.</p>
<p>Some final jargon: types with a kind other than <code>Type</code> are known as ‘higher-kinded types’, and parameterising
over higher-kinded types is known as ‘higher-kinded polymorphism’.</p>
<h3 id="type-classes"><a href="#type-classes">Type Classes</a></h3>
<p>Rust uses <a href="https://blog.rust-lang.org/2015/05/11/traits.html">traits</a> to coordinate sizing calculations. Each
datatype implicitly receives an implementation of the <code>Sized</code> trait, and every type variable that is relevant for
a sizing calculation is given a <code>Sized</code> bound. This means that trait resolution, an already useful feature, can
be re-used to perform size calculations.</p>
<p>Closely related to traits is the functional programming concept of type classes<sup><a href="#reference-constructor-classes" id="reference-constructor-classes:2">1</a></sup>. There are differences between the two,
but those differences don’t impact the results of this article. Type classes will prove a more convenient language
in which to discuss these ideas.</p>
<p>A type class (or trait) can be considered a predicate on types. A type class constraint (or trait bound) is an assertion
that the predicate must be true. For each constraint that is satisfied, there is corresponding ‘evidence’ that the
predicate is true.</p>
<p>When a type <code>T</code> has a <code>Sized</code> constraint, it is being asserted that the statement “<code>T</code> has a known size” is true. For
brevity, this will be written as <code>Sized T</code>. When this statement satisfied (for instance, when <code>T</code> is <code>int32</code>), the
evidence is produced is <em>the actual size</em> of <code>T</code> (when <code>Sized int32</code> is satisfied, the evidence
is the number <code>4</code> - the size of <code>int32</code>).</p>
<p>Generic types like <code>Two&lt;A&gt;</code> have a size that depends on their type parameter. In terms of constraints, it can
be said that <code>Sized A</code> <em>implies</em> <code>Sized Two&lt;A&gt;</code>. If <code>A</code> is <code>int32</code>, then its size is <code>4</code>, which implies that
<code>Two&lt;int32&gt;</code> has a size of <code>4 + 4 = 8</code>. Similarly, of <code>Pair</code> it can be said that <code>Sized A</code> implies [ <code>Sized B</code> implies
<code>Sized Pair&lt;A, B&gt;</code> ]. There is a choice between a curried an uncurried version; it could also be said that
[ <code>Sized A</code> <em>and</em> <code>Sized B</code> ] implies <code>Sized Pair&lt;A, B&gt;</code>, but the curried version will be used for convenience.</p>
<p>Note that type <em>constructors</em> don’t have a size. In other words, only types of kind <code>Type</code> have a size. A type constructor
such as <code>Two</code> (of kind <code>Type -&gt; Type</code>) has a size <em>function</em>. Given the sizes of the type constructor’s parameters,
a size function computes the size of the resulting datatype. <code>Two</code>’s size function is <code>\a -&gt; a + a</code>. <code>Pair</code>’s size
function <code>\a -&gt; b -&gt; a + b</code> (it could also be <code>\(a, b) -&gt; a + b</code> in an uncurried setting).</p>
<h3 id="problem-statement"><a href="#problem-statement">Problem Statement</a></h3>
<p>With the background out of the way, the specific problem can be stated:</p>
<p>When a type of kind <code>Type</code> is relevant for a size calculation, it is given a <code>Sized</code> constraint, which will be
satisfied with a concrete size as evidence. What is the equivalent notion of constraint and evidence for
higher-kinded types that contribute to size calculations?</p>
<h2 id="solution"><a href="#solution">Solution</a></h2>
<p>An elegant solution to this problem can found by introducing quantified class constraints<sup><a href="#reference-quantified-constraints" id="reference-quantified-constraints:1">2</a></sup>. Quantified constraints
are an extension to type classes that add implication and quantification to the language of constraints, and corresponding
notions of evidence.</p>
<p>Here’s new syntax of quantified size constraints:</p>
<pre><code>constraint ::=
  Sized type               (size constraint)
  constraint =&gt; constraint (implication constraint)
  forall A. constraint     (quantification constraint)</code></pre>
<p>The evidence for a constraint <code>c1 =&gt; c2</code> is a function that takes evidence for <code>c1</code> and produces evidence for <code>c2</code>, and the
evidence for <code>forall A. c</code> is just the evidence for <code>c</code>. The evidence for quantification constraints is a bit more nuanced
in general, but this description is accurate when only considering size constraints.</p>
<p>Concretely, this means that the sizing rules for higher-kinded types can now be expressed using constraints, and size
calculations involving higher-kinded types can be performed using type class resolution. It is now the
case that <code>forall A. Sized A =&gt; Sized Two&lt;A&gt;</code>, and the evidence for this constraint is the function <code>\a -&gt; a + a</code>.
The relevant constraint for <code>Pair</code> is <code>forall A. forall B. Sized A =&gt; Sized B =&gt; Sized Pair&lt;A, B&gt;</code> with evidence function
<code>\a b -&gt; a + b</code>.</p>
<p>This extends to types of <em>any</em> kind. For all types, there is a mechanical way to derive an appropriate size constraint based
only on type’s kind;
<code>T</code> of kind <code>Type</code> leads to <code>Sized T</code>, <code>U</code> of kind <code>Type -&gt; Type</code> leads to <code>forall A. Sized A =&gt; Sized U&lt;A&gt;</code>, and so on. In
datatypes and functions, any size-relevant type variables can be assigned a size constraint in this way, and the compiler
will use this extra information when monomorphising definitions.</p>
<p><a href="https://github.com/LightAndLight/sized-hkts">sized-hkts</a> is a minimal compiler that implements these ideas. It supports
higher-kinded polymorphism, functions and algebraic datatypes, and compiles to C. Kinds and size constraints are inferred,
requiring no annotations from the user.</p>
<p>Here’s some example code that illustrates the
<a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">higher-kinded data</a> pattern
(<a href="https://github.com/LightAndLight/sized-hkts/blob/master/examples/ex2.src">source</a>, <a href="https://github.com/LightAndLight/sized-hkts/blob/master/examples/ex2.out">generated C code</a>):</p>
<pre><code>enum ListF f a { Nil(), Cons(f a, ptr (ListF f a)) }
enum Maybe a { Nothing(), Just(a) }
struct Identity a = Identity(a)

fn validate&lt;a&gt;(xs: ListF Maybe a) -&gt; Maybe (ListF Identity a) {
  match xs {
    Nil() =&gt; Just(Nil()),
    Cons(mx, rest) =&gt; match mx {
      Nothing() =&gt; Nothing(),
      Just(x) =&gt; match validate(*rest) {
        Nothing() =&gt; Nothing(),
        Just(nextRest) =&gt; Just(Cons(Identity(x), new[nextRest]))
      }
    }
  }
}

fn main() -&gt; int32 {
  let
    a = Nil();
    b = Cons(Nothing(), new[a]);
    c = Cons(Just(1), new[b])
  in
    match validate(c) {
      Nothing() =&gt; 11,
      Just(xs) =&gt; match xs {
        Nil() =&gt; 22,
        Cons(x, rest) =&gt; x.0
      }
    }
}</code></pre>
<p>This code defines a linked list whose elements are wrapped in a generic ‘container’ type. It defines two possible
container types: <code>Maybe</code>, which is a possibly-empty container, and <code>Identity</code>, the single-element container.
<code>validate</code> takes a list whose elements are wrapped in <code>Maybe</code> and tries to replace all the <code>Just</code>s with <code>Identity</code>s.
If any of the elements of the list are <code>Nothing</code>, then the whole function returns <code>Nothing</code>.</p>
<p>Points of interest in the generated code include:</p>
<ul>
<li>5 types are generated, corresponding to:
<code>ListF Maybe int32</code>, <code>ListF Identity int32</code>, <code>Maybe int32</code>, <code>Identity int32</code>, and <code>Maybe (ListF Identity int32)</code></li>
<li>Only 1 version of <code>validate</code> is generated, because it is only used at one instantiation of <code>a</code>.</li>
<li>The generated code makes no use of <code>sizeof</code>; the datatype sizes are known after typechecking and inlined during
code generation. The compiler knows that <code>ListF Maybe int32</code> is naively <code>14</code> bytes wide
(<code>1 + max(1, 1 + 4) + 8</code>), whereas <code>ListF Identity int32</code> is <code>13</code> bytes wide (<code>max(1, 1 + 4) + 8</code>).</li>
<li>The datatype sizes are not necessarily consistent with <code>sizeof</code>, because they ignore alignment for simplicity.
At this point, factoring alignment into the size calculations is straightforward.</li>
</ul>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>Quantified class constraints provide an elegant framework for statically-sized higher-kinded types. On its own, this
can raise the abstraction ceiling for high-performance languages, but it also serves as the groundwork for ‘zero-cost’
versions of functional programming abstractions such as Functor, Applicative, and Traversable.</p>
<p>This work shows it’s definitely possible for Rust to support higher-kinded types in a reasonable manner, but
there are some less theoretical reasons why that might not be a good idea in practice. Adding ‘quantified trait bounds’
would require new syntax, and represents an additional concept for users to learn. Adding a kind system to Rust
would also be a controversial change; choosing to keep types uncurried would disadvantage prospective users of the
system, and changing to curried types would require rethinking of syntax and educational materials to maintain Rust’s
high standard of user experience.</p>
<h2 id="references"><a href="#references">References</a></h2>
<ol type="1">
<li><p><span id="reference-constructor-classes">Jones, M. P. (1995). A system of constructor classes:
overloading and implicit higher-order polymorphism. <em>Journal of functional programming</em>, 5(1),
1-35.</span> <a href="#reference-constructor-classes:1">↩︎<sup>1</sup></a> <a href="#reference-constructor-classes:2">↩︎<sup>2</sup></a></p></li>
<li><p><span id="reference-quantified-constraints">Bottu, G. J., Karachalias, G., Schrijvers, T.,
Oliveira, B. C. D. S., &amp; Wadler, P. (2017). Quantified class constraints. <em>ACM SIGPLAN Notices</em>,
52(10), 148-161.</span> <a href="#reference-quantified-constraints:1">↩︎</a></p></li>
</ol>
  <p class="post-navigation">
  
  <a href="/lambdas-are-codatatypes" title="Previous post: Lambdas are Codatatypes">← Lambdas are Codatatypes</a>
  

  
  <a href="/docker-cleanup-commands" title="Next post: Docker Cleanup Commands">Docker Cleanup Commands →</a>
  
</p>

</article>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'ielliott'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

  </main>

  <footer>
    <span>Isaac Elliott</span>

    <ol>
      <li><a class="footer-item-link" href="https://github.com/lightandlight">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M208.31 75.68A59.78 59.78 0 0 0 202.93 28a8 8 0 0 0-6.93-4 59.75 59.75 0 0 0-48 24h-24a59.75 59.75 0 0 0-48-24 8 8 0 0 0-6.93 4 59.78 59.78 0 0 0-5.38 47.68A58.14 58.14 0 0 0 56 104v8a56.06 56.06 0 0 0 48.44 55.47A39.8 39.8 0 0 0 96 192v8H72a24 24 0 0 1-24-24 40 40 0 0 0-40-40 8 8 0 0 0 0 16 24 24 0 0 1 24 24 40 40 0 0 0 40 40h24v16a8 8 0 0 0 16 0v-40a24 24 0 0 1 48 0v40a8 8 0 0 0 16 0v-40a39.8 39.8 0 0 0-8.44-24.53A56.06 56.06 0 0 0 216 112v-8a58.14 58.14 0 0 0-7.69-28.32M200 112a40 40 0 0 1-40 40h-48a40 40 0 0 1-40-40v-8a41.74 41.74 0 0 1 6.9-22.48 8 8 0 0 0 1.1-7.69 43.8 43.8 0 0 1 .79-33.58 43.88 43.88 0 0 1 32.32 20.06 8 8 0 0 0 6.71 3.69h32.35a8 8 0 0 0 6.74-3.69 43.87 43.87 0 0 1 32.32-20.06 43.8 43.8 0 0 1 .77 33.58 8.09 8.09 0 0 0 1 7.65 41.7 41.7 0 0 1 7 22.52Z"></path></svg>
        GitHub
      </a>

      <li><a class="footer-item-link" href="mailto:blog@id.ielliott.io">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 48H32a8 8 0 0 0-8 8v136a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a8 8 0 0 0-8-8m-20.57 16L128 133.15 52.57 64ZM216 192H40V74.19l82.59 75.71a8 8 0 0 0 10.82 0L216 74.19z"></path></svg>
        Email
      </a>

      <li><a class="footer-item-link" href="/feed.xml">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 192a8 8 0 0 1-16 0c0-79.4-64.6-144-144-144a8 8 0 0 1 0-16c88.22 0 160 71.78 160 160M64 104a8 8 0 0 0 0 16 72.08 72.08 0 0 1 72 72 8 8 0 0 0 16 0 88.1 88.1 0 0 0-88-88m4 72a12 12 0 1 0 12 12 12 12 0 0 0-12-12"></path></svg>
        Feed
      </a>
    </ol>
  </footer>

  
</body>

</html>
