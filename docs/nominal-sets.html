<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/fonts/SourceSerif4/SourceSerif4-Regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/SourceSans3/SourceSans3-Regular.woff2" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href="/res/fonts.css">
  <link rel="stylesheet" href="/res/style.css">

  <!-- defer non-critical stylesheet -->
  <link href="/res/syntax.css" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/res/syntax.css"></noscript>

  
  <link rel="stylesheet" href="/res/math.css">
  

  

  

  
  <title>Nominal Sets - blog.ielliott.io</title>
  

  <link rel="canonical" href="https://blog.ielliott.io/nominal-sets">
<link rel="alternate" type="application/atom+xml" title="blog.ielliott.io" href="/feed.xml">

<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="blog.ielliott.io">
<meta property="og:url" content="https://blog.ielliott.io/nominal-sets">
<meta property="og:title" content="Nominal Sets">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Nominal Sets">


<meta name="author" content="Isaac Elliott">
<meta name="description" content="Developing a variable binding library for Rust, based on the
theory of nominal sets.">
<meta property="og:description" content="Developing a variable binding library for Rust, based on the
theory of nominal sets.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-07-04T06:41+00:00">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline":"Nominal Sets",
  "author": {
    "@type":"Person",
    "name":"Isaac Elliott"
  },
  "datePublished":"2023-07-04T06:41+00:00",
  "dateModified":"2023-07-04T06:41+00:00",
  "description":"Developing a variable binding library for Rust, based on the
theory of nominal sets.",
  "mainEntityOfPage": {
    "@type":"WebPage",
    "@id":"https://blog.ielliott.io/nominal-sets"
  },
  "url": "https://blog.ielliott.io/nominal-sets"
}
</script>
</head>

<body>
  <header>
    <h1><a href="/">I E</a></h1>
    <nav>
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/about">About</a>
        <li><a href="/resources">Resources</a>
      </ol>
    </nav>
  </header>

  <main>
    
    <script id="mathml-polyfill-script" src="/res/mathml-polyfill.js"></script>
    

    <article>
  <header>
    <h1>Nominal Sets</h1>
    <p class="post-metadata">
       4 July, 2023
      
      â‹…
      
<a class="post-metadata-tag" href="/tags/programming">programming</a>

<a class="post-metadata-tag" href="/tags/mathematics">mathematics</a>


      
    </p>
  </header>
  <div class="intro-wrapper">
<div class="intro">
<p>For years Iâ€™ve used <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De
Bruijn indices</a>, in part because
of Haskellâ€™s <a href="https://hackage.haskell.org/package/bound"><code>bound</code></a> library, which abstracts (pun
intended) De Bruijn indexed binders in a simple and type-safe way. Having learned to â€œthinkâ€ using de Bruijn indices, I naturally used them when I wrote
<a href="https://github.com/lightandlight/ipso">Ipso</a>, which is written in Rust. I wished I had <code>bound</code>, so I tried to port it to
Rust. Unfortunately, <code>bound</code> relies on <a href="https://en.wikipedia.org/wiki/Polymorphic_recursion">polymorphic
recursion</a>, which Rust
<a href="https://github.com/rust-lang/rust/issues/4287#issuecomment-11846582">doesnâ€™t really support</a>.</p>
<p>Writing all that variable binding machinery in Rust was tolerable, but Ipso probably isnâ€™t the last
programming language that Iâ€™ll build with Rust. When itâ€™s time for me to build the next one, Iâ€™d
like to use a variable binding library instead. I think
<a href="https://docs.rs/moniker/latest/moniker/"><code>moniker</code></a> is the only<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> such library on
<a href="https://crates.io/">crates.io</a>, and I might yet use it. In the meantime, Iâ€™d
like to explore an alternative way of tackling the problem, inspired by a formalism called â€œnominal setsâ€.</p>
</div>
<div id="toc">
<h3>Contents</h3>
<ul>
<li><a href="#why-did-i-write-this">Why did I write this?</a></li>
<li><a href="#names-and-binders">Names and binders</a></li>
<li><a href="#nominal-sets">Nominal sets</a>
<ul>
<li><a href="#names">Names</a></li>
<li><a href="#permutations">Permutations</a>
<ul>
<li><a href="#permutations-on-functions">Permutations on functions</a></li>
</ul></li>
<li><a href="#support">Support</a>
<ul>
<li><a href="#minimal-support">Minimal support</a></li>
<li><a href="#the-support-of-a-function">The support of a function</a></li>
</ul></li>
<li><a href="#freshness">Freshness</a></li>
<li><a href="#name-binding">Name binding</a></li>
<li><a href="#the-category-of-nominal-sets">The category of nominal sets</a></li>
<li><a href="#some-adjunctions">Some adjunctions</a></li>
</ul></li>
<li><a href="#showing-off">Showing off</a>
<ul>
<li><a href="#alpha-equivalence">Alpha equivalence</a></li>
<li><a href="#capture-avoiding-substitution">Capture-avoiding substitution</a></li>
</ul></li>
<li><a href="#final-thoughts">Final thoughts</a></li>
<li><a href="#appendix-a-proofs">Appendix A: Proofs</a></li>
</ul>
</div>
</div>
<h2 id="why-did-i-write-this"><a href="#why-did-i-write-this">Why did I write this?</a></h2>
<p>I have two reasons for writing this article. The first is to improve my understanding of
nominal sets, and my general mathematical ability.
Years ago I <a href="https://blog.ielliott.io/writing%3E">wrote about</a> my sense of the importance of writing,
and that line of reasoning continues to motivate me. More recently, <a href="http://www.paulgraham.com">Paul Graham</a> has written a much
more eloquent <a href="http://www.paulgraham.com/words.html">essay</a> on the topic.</p>
<p>The second is to contribute another introduction to nominal sets. I learned about nominal sets from
primary sources: a book (via my state library) and few papers from the pioneering authors, and slides from tutorials theyâ€™d given.
In total, five or six resources from a couple of authors. When I didnâ€™t understand something I cycled
between resources, as if trying to triangulate an understanding. I think that more explanations, written by different people, would have increased the chances
of finding an explanation that clicked for me. While I cover the same introductory topics
as the primary sources, I hope that Iâ€™ll do it differently enough to be valuable to someone.</p>
<h2 id="names-and-binders"><a href="#names-and-binders">Names and binders</a></h2>
<p>Here is the core Rust implementation of my nominal-sets-inspired approach:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> name <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">Hash</span><span class="op">,</span> <span class="bu">Clone</span><span class="op">,</span> <span class="bu">Copy</span><span class="at">)]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">struct</span> Name(<span class="dt">usize</span>)<span class="op">;</span> <span class="co">// (1)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="pp">lazy_static!</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">static</span> <span class="kw">ref</span> COUNTER<span class="op">:</span> AtomicU64 <span class="op">=</span> <span class="pp">AtomicU64::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> fresh() <span class="op">-&gt;</span> Name <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      Name(COUNTER<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> <span class="pp">std::sync::atomic::Ordering::</span>Relaxed))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> binder <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">struct</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;{</span> <span class="co">// (2)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> Name<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    body<span class="op">:</span> T</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* (5)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Correctness condition: `f` should only use its argument to construct the `T`.</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    The name shouldn't be made to outlive `f` in any other way, e.g. by storing</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">    it in a mutable variable.</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> bind(f<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(Name) <span class="op">-&gt;</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span> <span class="co">// (3)</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>fresh<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> name <span class="op">=</span> fresh()<span class="op">;</span> <span class="co">// (4)</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>      Binder<span class="op">{</span> name<span class="op">,</span> body<span class="op">:</span> f(name) <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* (6)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">    Correctness condition: `f` should not &quot;leak&quot; its `Name` argument. After `f` has</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">    returned, the name shouldn't be accessible outside the binder.</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> unbind<span class="op">&lt;</span>R<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(<span class="op">&amp;</span>Name<span class="op">,</span> <span class="op">&amp;</span>T) <span class="op">-&gt;</span> R) <span class="op">-&gt;</span> R <span class="op">{</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>      f(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>name<span class="op">,</span> <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>body)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Names (1) are opaque and can be compared for equality.</p>
<p>A binder (2) is a pair of a name with some type <code>T</code>, within which the name is considered <em>bound</em>.</p>
<p><code>bind</code> (3) is the only way to create binders, which is also the only time new names are introduced (4).
Since the fields of <code>Binder</code> are hidden, every binder binds a unique name.</p>
<p>Binder introduction (<code>bind</code>) and elimination (<code>unbind</code>) come with correctness conditions (5) (6) that
prevent bound names from â€œescaping their scopeâ€. Programs that follow these rules are
capture-avoiding by construction; any terms that are substituted under a binder will not contain the
name bound by that binder.</p>
<p>Thereâ€™s more to add, such as <code>Clone</code> and <code>Eq</code> implementations for <code>Binder</code>. As I explain nominal
sets Iâ€™ll translate the important concepts to code, so that by the end weâ€™ll have a decent
variable binding library.</p>
<h2 id="nominal-sets"><a href="#nominal-sets">Nominal sets</a></h2>
<p>Nominal sets<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><sup>,</sup><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><sup>,</sup><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a><sup>,</sup><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> is a theory of
names and name binding, intended to help with implementing and verifying programming languages. Its most
remarkable feature is an account of algebraic datatypes and recursion modulo <a href="https://stackoverflow.com/a/47762545/2884502">alpha
equivalence</a>. In practise, this gives an elegant way
to work with abstract syntax trees while being able to ignore any specific choice of names.</p>
<p>I like nominal sets as a formalism because they are a good example of how category theory can inform library design.</p>
<h3 id="names"><a href="#names">Names</a></h3>
<p>Names can be drawn from any <a href="https://mathworld.wolfram.com/CountablyInfinite.html">countably infinite</a> set. In the literature, this set is written as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ”¸</mi><annotation encoding="application/x-tex">\mathbb{A}</annotation></semantics></math> (for <strong>A</strong>tom). Iâ€™ll keep to this convention while explaining the math.</p>
<p>The only operation on names is equality comparison, which Iâ€™ll write as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mover><mo>=</mo><mo accent="false">?</mo></mover><mi>b</mi></mrow><annotation encoding="application/x-tex">a \stackrel{?}{=} b</annotation></semantics></math>.</p>
<h3 id="permutations"><a href="#permutations">Permutations</a></h3>
<p>A theory that deals with alpha equivalence needs a notion of â€œrenaming variablesâ€. Nominal sets uses
<a href="https://en.wikipedia.org/wiki/Permutation">permutations</a> of names.</p>
<p>A permutation of names (from here on, just â€œa permutationâ€) is a bijection on names. Iâ€™ll write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î </mi><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> for the set of permutations, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï€</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> for any particular permutation.
Being functions, permutations are used by <em>applying</em> them to names, written <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi(a)</annotation></semantics></math>.
A permutation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï€</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is â€œfiniteâ€ when a finite set of atoms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> satisfies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰ </mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\pi(a) \neq a</annotation></semantics></math>.</p>
<p>The fundamental permutation is the swapping of two names, written <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \; b)</annotation></semantics></math>. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \; b)</annotation></semantics></math> is
the bijection mapping <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, and any other name to itself.
Every finite permutation can be
decomposed into a sequence of swaps
(<a id="proof-1-link" href="nominal-sets-proofs#proof-1">A.1</a>).</p>
<p>In Rust I represent (finite) permutations using a <code>HashMap</code>. Applying takes keys to values, and any names not
in the <code>HashMap</code> are mapped to themselves. In other words, the <code>HashMap</code> represents a
permutation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï€</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> by storing a pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, \pi(x))</annotation></semantics></math> for
each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰ </mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi(x) \neq x</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> permutation <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>Name<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">struct</span> Permutation(HashMap<span class="op">&lt;</span>Name<span class="op">,</span> Name<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> Permutation <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> swap(a<span class="op">:</span> Name<span class="op">,</span> b<span class="op">:</span> Name) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Self</span>(<span class="pp">HashMap::</span>from([(a<span class="op">,</span> b)<span class="op">,</span> (b<span class="op">,</span> a)]))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> apply(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name) <span class="op">-&gt;</span> Name <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">self</span><span class="op">.</span>get(name)<span class="op">.</span>copied()<span class="op">.</span>unwrap_or(<span class="op">*</span>name)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Permutations form a <a href="https://en.wikipedia.org/wiki/Group_(mathematics)">group</a>. The identity
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¹</mi><annotation encoding="application/x-tex">\iota</annotation></semantics></math>) is the identity function. Multiplication (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>âˆ˜</mi><annotation encoding="application/x-tex">\circ</annotation></semantics></math>) is function composition. Every
permutation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï€</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> has an inverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ï€</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\pi^{-1}</annotation></semantics></math> (because theyâ€™re bijections).</p>
<p>In the code I call the multiplication function <code>after</code> so itâ€™s easier to remember the order of the
permutations.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> id() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>      Permutation(<span class="pp">HashMap::</span>new())</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> after(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> <span class="kw">mut</span> permutation <span class="op">=</span> other</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span>iter()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span>map(<span class="op">|</span>(key<span class="op">,</span> value)<span class="op">|</span> (<span class="op">*</span>key<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>apply(value)))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span>HashMap<span class="op">&lt;</span>Name<span class="op">,</span> Name<span class="op">&gt;&gt;</span>()<span class="op">;</span> <span class="co">// (1)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>      permutation<span class="op">.</span>extend(<span class="kw">self</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span>iter()</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span>filter(<span class="op">|</span>(key<span class="op">,</span> value)<span class="op">|</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> other<span class="op">.</span>contains(key) <span class="op">{</span> </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>              <span class="cn">None</span> </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Some</span>((key<span class="op">,</span> value)) </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span>))<span class="op">;</span> <span class="co">// (2)</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>      Permutation(permutation)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> inverse(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>      Permutation(<span class="kw">self</span><span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>(key<span class="op">,</span> value)<span class="op">|</span> (<span class="op">*</span>value<span class="op">,</span> <span class="op">*</span>key))<span class="op">.</span>collect())</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p><code>after</code>, acting on <code>HashMap</code>s under the hood, needs a more clever definition than I
first expected. The final permutation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>f</mi></msub><mo>âˆ˜</mo><msub><mi>Ï€</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\pi_f \circ \pi_g</annotation></semantics></math> is constructed in two parts. The first
part (1) computes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mi>g</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_f(\pi_g(x))</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>g</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰ </mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi_g(x) \neq x</annotation></semantics></math>. The second part (2)
computes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_f(x)</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>g</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi_g(x) = x</annotation></semantics></math>. For these values, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mi>g</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Ï€</mi><mi>f</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_f(\pi_g(x)) =
\pi_f(x)</annotation></semantics></math>. The first time I wrote this function, I mistakenly thought the first part would be enough.</p>
<p>Names are arenâ€™t the only thing that can be affected by a permutation. â€œApplyingâ€ a permutation
generalises to other sets as the <a href="https://mathworld.wolfram.com/GroupAction.html">action</a> of
permutations on those sets. Permutations can act on a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> when there exists a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î±</mi><mi>X</mi></msub><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>Î </mi><mo>Ã—</mo><mi>X</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\alpha_X \; : \; \Pi \times X \rightarrow X</annotation></semantics></math>
satisfying the following properties:</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><msub><mi>Î±</mi><mi>X</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î¹</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\forall x. \; \alpha_X(\iota, x) = x</annotation></semantics></math> (identity)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><msub><mi>Î±</mi><mi>X</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mn>1</mn></msub><mo>âˆ˜</mo><msub><mi>Ï€</mi><mn>2</mn></msub><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Î±</mi><mi>X</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mn>1</mn></msub><mo>,</mo><msub><mi>Î±</mi><mi>X</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mn>2</mn></msub><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\forall x. \; \alpha_X(\pi_1 \circ \pi_2, x) = \alpha_X(\pi_1, \alpha_X(\pi_2, x))</annotation></semantics></math> (composition)</li>
</ol>
<p>Instead of writing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î±</mi><mi>X</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha_X(\pi, x)</annotation></semantics></math> for a specific permutation action, Iâ€™ll use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi \cdot x</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">/*</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">  Laws:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">  * `forall x. x.permute_by(Permutation::id()) == x` (identity)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">  * `forall x. x.permute_by(f.after(g)) == x.permute_by(g).permute_by(f)` (composition)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">trait</span> Permutable <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Permutations trivially act on names: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mi>a</mi><mo>=</mo><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi \cdot a = \pi(a)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> Permutable <span class="cf">for</span> Name <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      permutation<span class="op">.</span>apply(<span class="kw">self</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Permutations also trivially act on themselves: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mi>f</mi></msub><mo>â‹…</mo><msub><mi>Ï€</mi><mi>g</mi></msub><mo>=</mo><msub><mi>Ï€</mi><mi>f</mi></msub><mo>âˆ˜</mo><msub><mi>Ï€</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\pi_f \cdot \pi_g = \pi_f \circ \pi_g</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> Permutable <span class="cf">for</span> Permutation <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      permutation<span class="op">.</span>after(<span class="kw">self</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Permutations act on pairs element-wise: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo>,</mo><mi>Ï€</mi><mo>â‹…</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi \cdot (x, y) = (\pi \cdot x, \pi \cdot y)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Permutable<span class="op">,</span> B<span class="op">:</span> Permutable<span class="op">&gt;</span> Permutable <span class="cf">for</span> (A<span class="op">,</span> B) <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>permute_by(permutation)<span class="op">,</span> <span class="kw">self</span><span class="op">.</span><span class="dv">1</span><span class="op">.</span>permute_by(permutation))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>And similarly for sums: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><msub><mtext mathvariant="normal">in</mtext><mi>L</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">in</mtext><mi>L</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>âˆ§</mo><mspace width="0.278em"></mspace><mi>Ï€</mi><mo>â‹…</mo><msub><mtext mathvariant="normal">in</mtext><mi>R</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">in</mtext><mi>R</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi \cdot \text{in}_L(x) =
\text{in}_L(\pi \cdot x) \; \land \; \pi \cdot \text{in}_R(y) =
\text{in}_R(\pi \cdot y)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Permutable<span class="op">,</span> B<span class="op">:</span> Permutable<span class="op">&gt;</span> Permutable <span class="cf">for</span> <span class="pp">either::</span>Either<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">use</span> <span class="pp">either::</span>Either<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        Left(a) <span class="op">=&gt;</span> Left(a<span class="op">.</span>permute_by(permutation))<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        Right(b) <span class="op">=&gt;</span> Right(b<span class="op">.</span>permute_by(permutation))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>On a more Rust-specific note, heap allocation is <code>Permutable</code> because itâ€™s essentially a
single-element product:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> Permutable <span class="cf">for</span> <span class="dt">Box</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> inner <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>as_ref()<span class="op">.</span>permute_by(permutation)<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(inner)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// mod permutation</span></span></code></pre></div>
<h4 id="permutations-on-functions"><a href="#permutations-on-functions">Permutations on functions</a></h4>
<p>Permutations can also act on functions: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Ï€</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(\pi \cdot f)(x) = \pi \cdot f(\pi^{-1} \cdot x)</annotation></semantics></math>. For my purposes this is only important in theory, so I wonâ€™t
implement it in Rust. This definition is derived from the requirement that permutations distribute over function application: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi
\cdot f(x) = (\pi \cdot f)(\pi \cdot x)</annotation></semantics></math>.</p>
<h3 id="support"><a href="#support">Support</a></h3>
<p>A set of names <em>supports</em> a value when the value â€œdependsâ€ on those names. Hereâ€™s the formal definition:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mi>X</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">supports</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mo>âˆˆ</mo><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>x</mi><mo>âˆˆ</mo><mi>X</mi><mo>,</mo><mspace width="0.278em"></mspace><mo>âˆ€</mo><mi>Ï€</mi><mi>.</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>a</mi><mo>âˆˆ</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŸ¹</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo>=</mo><mi>x</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\text{supports} \; : \; \mathcal{P}(\mathbb{A}) \times X
\\
\text{supports} =
\{ \;
(\bar{a}, x) \; | \; 
\bar{a} \in \mathcal{P}(\mathbb{A}), \;
x \in X, \;
\forall \pi. \; (\forall a \in \bar{a}. \; \pi(a) = a) \implies
\pi \cdot x = x 
\; \}
\end{array}
</annotation></semantics></math></p>
<p>In English: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>x</mi></mrow><annotation encoding="application/x-tex">\bar{a} \; \text{supports} \; x</annotation></semantics></math> when all permutations that keep the elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><annotation encoding="application/x-tex">\bar{a}</annotation></semantics></math> the same
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mi>a</mi><mo>âˆˆ</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\forall a \in \bar{a}. \; \pi(a) = a)</annotation></semantics></math> also keep <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
the same (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi \cdot x = x</annotation></semantics></math>).</p>
<p>For example, every name must support itself: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo stretchy="false" form="postfix">}</mo><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\{a\} \; \text{supports} \; a</annotation></semantics></math>
(<a id="proof-2-link" href="nominal-sets-proofs#proof-2">A.2</a>).
More importantly, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆƒ</mo><mi>b</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>b</mi><mo>â‰ </mo><mi>a</mi><mspace width="0.278em"></mspace><mo>âˆ§</mo><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">{</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\exists b. \; b \neq a \; \land \; \{b\} \; \text{supports} \; a</annotation></semantics></math> is false
(<a id="proof-3-link" href="nominal-sets-proofs#proof-3">A.3</a>).</p>
<p>Pairs are supported element-wise:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‡”</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>x</mi><mo>âˆ§</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>y</mi></mrow><annotation encoding="application/x-tex">
\bar{a}  \; \text{supports} \; (x, y) \iff \bar{a} \; \text{supports} \; x
\land \bar{a} \; \text{supports} \; y
</annotation></semantics></math></p>
<p>And sums variant-wise:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><msub><mtext mathvariant="normal">in</mtext><mi>L</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‡”</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>x</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><msub><mtext mathvariant="normal">in</mtext><mi>R</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‡”</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>y</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\bar{a} \; \text{supports} \; \text{in}_L(x) \iff \bar{a} \; \text{supports} \; x
\\
\bar{a} \;
\text{supports} \; \text{in}_R(y) \iff \bar{a} \; \text{supports} \; y
\end{array}
</annotation></semantics></math></p>
<p>Functions have a permutation action, and therefore the notion of support also applies to them.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>f</mi><mo>â‡”</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ€</mo><mi>Ï€</mi><mi>.</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>a</mi><mo>âˆˆ</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŸ¹</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mo>=</mo><mi>f</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ€</mo><mi>Ï€</mi><mi>.</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>a</mi><mo>âˆˆ</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŸ¹</mo><mo>âˆ€</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ€</mo><mi>Ï€</mi><mi>.</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>a</mi><mo>âˆˆ</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŸ¹</mo><mo>âˆ€</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Ï€</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{ll}
\bar{a} \; \text{supports} \; f \iff &amp; \forall \pi. \; (\forall a \in \bar{a}. \; \pi(a) = a)
\implies \pi \cdot f = f
\\
&amp; \forall \pi. \; (\forall a \in \bar{a}. \; \pi(a) = a) 
\implies \forall x. \; (\pi \cdot f)(x) = f(x)
\\
&amp; \forall \pi. \; (\forall a \in \bar{a}. \; \pi(a) = a) 
\implies \forall x. \; \pi \cdot f(\pi^{-1} \cdot x) = f(x)
\end{array}
</annotation></semantics></math></p>
<h4 id="minimal-support"><a href="#minimal-support">Minimal support</a></h4>
<p>The definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">supports</mtext><annotation encoding="application/x-tex">\text{supports}</annotation></semantics></math> is a bit â€œlooseâ€, because it allows names that donâ€™t occur in a value
to support said value. For example, for names <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\{a,b\} \; \text{supports} \; a</annotation></semantics></math>
(<a id="proof-4-link" href="nominal-sets-proofs#proof-4">A.4</a>).</p>
<p>The notion of <em>minimal</em> support tightens this up. The minimal support of a value consists of only
the names the value <em>actually</em> depends on. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><annotation encoding="application/x-tex">\bar{a}</annotation></semantics></math> is the minimal support of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> when it is a subset of all other sets that support <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">supports</mtext><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mi>X</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">supports</mtext><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mo>âˆˆ</mo><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>x</mi><mo>âˆˆ</mo><mi>X</mi><mo>,</mo><mspace width="0.278em"></mspace><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>x</mi><mo>,</mo><mo>âˆ€</mo><mover><mi>x</mi><mo accent="true">â€¾</mo></mover><mi>.</mi><mspace width="0.278em"></mspace><mover><mi>x</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mtext mathvariant="normal">supports</mtext><mspace width="0.278em"></mspace><mi>x</mi><mo>âŸ¹</mo><mover><mi>a</mi><mo accent="true">â€¾</mo></mover><mo>âŠ†</mo><mover><mi>x</mi><mo accent="true">â€¾</mo></mover><mspace width="0.278em"></mspace><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\text{supports}_{min} \; : \; \mathcal{P}(\mathbb{A}) \times X
\\
\text{supports}_{min} =
\{ \;
(\bar{a}, x) \; | \; \bar{a} \in \mathcal{P}(\mathbb{A}), \; x \in X, \;
\bar{a} \; \text{supports} \; x, \forall \bar{x}. \; \bar{x} \; \text{supports} \; x \implies
\bar{a} \subseteq \bar{x} 
\; \}
\end{array}
</annotation></semantics></math></p>
<p>I can say <em>the</em> minimal support, because itâ€™s unique for every value
(<a id="proof-5-link" href="nominal-sets-proofs#proof-5">A.5</a>). From now on Iâ€™ll just refer to â€œthe minimal supportâ€ as â€œthe supportâ€, and use a â€œminimal
supportâ€ function instead of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">supports</mtext><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><annotation encoding="application/x-tex">\text{supports}_{min}</annotation></semantics></math> relation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">support</mtext><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>X</mi><mo>â†’</mo><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> such that </mtext><mspace width="0.333em"></mspace></mrow><mo>âˆ€</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><mtext mathvariant="normal">support</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><msub><mtext mathvariant="normal">supports</mtext><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mspace width="0.278em"></mspace><mi>x</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\text{support} \; : \; X \rightarrow \mathcal{P}(\mathbb{A}) \text{ such that } \forall x. \; \text{support}(x) \; \text{supports}_{min} \; x
\end{array}
</annotation></semantics></math></p>
<p>Putting it all into code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> support <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>Name<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">trait</span> Supported<span class="op">:</span> Permutable <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// Computes the minimal support of a value.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> Supported <span class="cf">for</span> Name <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      <span class="pp">HashSet::</span>from([<span class="op">*</span><span class="kw">self</span>])</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Supported<span class="op">,</span> B<span class="op">:</span> Supported<span class="op">&gt;</span> Supported <span class="cf">for</span> (A<span class="op">,</span> B) <span class="op">{</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>support()<span class="op">.</span><span class="kw">union</span>(<span class="kw">self</span><span class="op">.</span><span class="dv">1</span><span class="op">.</span>support())<span class="op">.</span>collect()</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Supported<span class="op">,</span> B<span class="op">:</span> Supported<span class="op">&gt;</span> Supported <span class="cf">for</span> <span class="pp">either::</span>Either<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">use</span> <span class="pp">either::</span>Either<span class="op">;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        Left(a) <span class="op">=&gt;</span> a<span class="op">.</span>support()<span class="op">,</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        Right(b) <span class="op">=&gt;</span> b<span class="op">.</span>support()</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> Supported <span class="cf">for</span> <span class="dt">Box</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">self</span><span class="op">.</span>as_ref()<span class="op">.</span>support()</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="the-support-of-a-function"><a href="#the-support-of-a-function">The support of a function</a></h4>
<p>I think of the support of a function as the set of names that have been â€œcapturedâ€ by the function.
The identity function returns its argument and does nothing else, so itâ€™s supported by the empty set
(<a id="proof-6-link" href="nominal-sets-proofs#proof-6">A.6</a>).
A function that compares its two name arguments and nothing else
(like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">cmp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mover><mo>=</mo><mo accent="false">?</mo></mover><mi>b</mi></mrow><annotation encoding="application/x-tex">\text{cmp}(a, b) = a \stackrel{?}{=} b</annotation></semantics></math>)
is also supported by the empty set
(<a id="proof-7-link" href="nominal-sets-proofs#proof-7">A.7</a>).
A function that references names other than its arguments has those names in its support. For
example, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> must be in the support of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">iffy</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mover><mo>=</mo><mo accent="false">?</mo></mover><mi>x</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> then </mtext><mspace width="0.333em"></mspace></mrow><mi>b</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> else </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">\text{iffy}(x) = \text{if } a \stackrel{?}{=} x \text{ then } b
\text{ else } x</annotation></semantics></math>
(<a id="proof-8-link" href="nominal-sets-proofs#proof-8">A.8</a>).</p>
<h3 id="freshness"><a href="#freshness">Freshness</a></h3>
<p>A name <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> is fresh for a value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> (written <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi></mrow><annotation encoding="application/x-tex">a \; \# \; x</annotation></semantics></math>) when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>âˆ‰</mo><msub><mtext mathvariant="normal">support</mtext><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a \notin \text{support}_{min}(x)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> support <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">fn</span> fresh_for<span class="op">&lt;</span>T<span class="op">:</span> Supported<span class="op">&gt;</span>(name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>value<span class="op">.</span>support()<span class="op">.</span>contains(name)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since atoms are drawn from a countably infinite set, we take as an axiom that for any set of atoms there exists an atom that is fresh for them:
<span id="axiom-choose-a-fresh-name">
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mover><mi>x</mi><mo accent="true">â€¾</mo></mover><mo>âˆˆ</mo><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi><mspace width="0.278em"></mspace><mo>âˆƒ</mo><mi>a</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mover><mi>x</mi><mo accent="true">â€¾</mo></mover></mrow><annotation encoding="application/x-tex">\forall \bar{x} \in \mathcal{P}(\mathbb{A}). \; \exists a. \; a \; \# \; \bar{x}</annotation></semantics></math>
</span>.
This is known as the â€œchoose-a-fresh-nameâ€ principle, and itâ€™s what motivates the global number generator I use for
<code>Name</code>s.</p>
<p>Some useful properties involving freshness:</p>
<ul>
<li><p>Swapping fresh names does nothing: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi><mo>âˆ§</mo><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi><mo>âŸ¹</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a \; \# \; x \land b \; \# \; x \implies (a \; b) \cdot x = x</annotation></semantics></math>
(<a id="proof-9-link" href="nominal-sets-proofs#proof-9">A.9</a>).</p></li>
<li><p>Freshness â€œdistributesâ€ across functions: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>f</mi><mo>âˆ§</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi><mo>âŸ¹</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a \; \# \; f \land a \; \# \; x \implies a \; \# \; f(x)</annotation></semantics></math>
(<a id="proof-10-link" href="nominal-sets-proofs#proof-10">A.10</a>).</p></li>
</ul>
<h3 id="name-binding"><a href="#name-binding">Name binding</a></h3>
<p>Name binding (written <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">[\mathbb{A}]X</annotation></semantics></math>) is the <a href="https://en.wikipedia.org/wiki/Equivalence_class">quotient</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> of name-value pairs
by a sort of â€œgeneralised alpha equivalenceâ€. Elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">[\mathbb{A}]X</annotation></semantics></math> are written as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\langle a \rangle x</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo>Ã—</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mo>âˆ¼</mo><mi>Î±</mi></msub></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mspace width="0.278em"></mspace></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mo>âˆ¼</mo><mi>Î±</mi></msub><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo>Ã—</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ”¸</mi><mo>Ã—</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mo>âˆ¼</mo><mi>Î±</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>â€²</mi><mo>,</mo><mi>x</mi><mi>â€²</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><mi>a</mi><mo>,</mo><mi>a</mi><mi>â€²</mi><mo>âˆˆ</mo><mi>ğ”¸</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>x</mi><mo>,</mo><mi>x</mi><mi>â€²</mi><mo>âˆˆ</mo><mi>X</mi><mo>,</mo><mspace width="0.278em"></mspace><mo>âˆƒ</mo><mi>b</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>a</mi><mi>â€²</mi><mo>,</mo><mi>x</mi><mi>â€²</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>âˆ§</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>â€²</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mi>â€²</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
[\mathbb{A}]X = (\mathbb{A} \times X) / \sim_\alpha
\\ \; \\
\sim_\alpha \; : \; (\mathbb{A} \times X) \times (\mathbb{A} \times X)
\\
\sim_\alpha \; = \{ \; 
((a, x), (a', x')) \; | \;
a, a' \in \mathbb{A}, \;
x, x' \in X, \;
\exists b. \; 
b \; \# \; (a, x, a', x')
\; \land \;
(a \; b) \cdot x = (a' \; b) \cdot x'
\; \}
\end{array}
</annotation></semantics></math></p>
<p>Two name binders are considered equal when renaming their bound name to a completely
fresh name makes their bodies equal.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">[\mathbb{A}]X</annotation></semantics></math> is the <code>Binder</code> type that I defined at the beginning. Now we have tools to
define equality on <code>Binder</code>s:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">PartialEq</span><span class="op">&gt;</span> <span class="bu">PartialEq</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> eq(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>fresh<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="op">=</span> fresh()<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">self</span><span class="op">.</span>body<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(<span class="kw">self</span><span class="op">.</span>name<span class="op">,</span> b)) <span class="op">==</span> </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span>body<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(other<span class="op">.</span>name<span class="op">,</span> b))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Eq</span><span class="op">&gt;</span> <span class="bu">Eq</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{}</span></span></code></pre></div>
<p>Since every binder binds a unique name and binders are immutable, there is a fast path for equality: two binders that
bind the same name are actually the same binder.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">PartialEq</span><span class="op">&gt;</span> <span class="bu">PartialEq</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> eq(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>fresh<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>name <span class="op">==</span> other<span class="op">.</span>name <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      <span class="cn">true</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> b <span class="op">=</span> fresh()<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">self</span><span class="op">.</span>body<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(<span class="kw">self</span><span class="op">.</span>name<span class="op">,</span> b)) <span class="op">==</span> </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>          other<span class="op">.</span>body<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(other<span class="op">.</span>name<span class="op">,</span> b))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Eq</span><span class="op">&gt;</span> <span class="bu">Eq</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{}</span></span></code></pre></div>
<p>Name binding has a permutation action and a finite support.</p>
<p>Permutation action: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>â‹…</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>Ï€</mi><mo>â‹…</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi \cdot \langle a \rangle x = \langle \pi \cdot a \rangle (\pi \cdot x)</annotation></semantics></math></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> Permutable<span class="op">&gt;</span> Permutable <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    Binder<span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      name<span class="op">:</span> name<span class="op">.</span>permute_by(permutation)<span class="op">,</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      body<span class="op">:</span> body<span class="op">.</span>permute_by(permutation)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The support of a name binder excludes its bound name: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">support</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mtext mathvariant="normal">support</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\text{support} (\langle a \rangle x) \; = \text{support}(x) - \{ a \}</annotation></semantics></math> (<a id="proof-11-link" href="nominal-sets-proofs#proof-11">A.11</a>).
Freshness is the negation of this: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi><mspace width="0.278em"></mspace><mo>â‡”</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mi>a</mi><mspace width="0.278em"></mspace><mo>âˆ¨</mo><mspace width="0.278em"></mspace><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi></mrow><annotation encoding="application/x-tex">b \; \# \; \langle a \rangle x \; \iff \; b = a \; \lor \; b \; \# \; x</annotation></semantics></math> (<a id="proof-12-link" href="nominal-sets-proofs#proof-12">A.12</a>).</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> Supported<span class="op">&gt;</span> Supported <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> support <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>body<span class="op">.</span>support()<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    support<span class="op">.</span>remove(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>name)<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    support</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can now define <code>Clone</code> for binders. It respects the property that every <code>Binder</code> binds a unique name.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Clone</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> clone(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">self</span><span class="op">.</span>unbind(<span class="op">|</span>name<span class="op">,</span> body<span class="op">|</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Binder::</span>new(<span class="op">|</span>new_name<span class="op">|</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        body<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(name<span class="op">,</span> new_name))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When reasoning about binder equality, itâ€™s often inconvenient to find an atom <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>a</mi><mi>â€²</mi><mo>,</mo><mi>x</mi><mi>â€²</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b \; \# \; (a, x, a', x')</annotation></semantics></math>
such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>â€²</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mi>â€²</mi></mrow><annotation encoding="application/x-tex">(a \; b) \cdot x = (a' \; b) \cdot x'</annotation></semantics></math>. When thatâ€™s the case, we prove an
equivalent property: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mi>b</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>b</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>a</mi><mi>â€²</mi><mo>,</mo><mi>x</mi><mi>â€²</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŸ¹</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>â€²</mi><mspace width="0.278em"></mspace><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mi>x</mi><mi>â€²</mi></mrow><annotation encoding="application/x-tex">\forall b. \; b \; \# \; (a, x, a', x') \implies (a \; b) \cdot x = (a' \; b) \cdot x'</annotation></semantics></math>
(<a id="proof-13-link" href="nominal-sets-proofs#proof-13">A.13</a>).
Any specific fresh atom is interchangeable with all fresh atoms that satisfy the same conditions.</p>
<h3 id="the-category-of-nominal-sets"><a href="#the-category-of-nominal-sets">The category of nominal sets</a></h3>
<p>Any set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> with a permutation action <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï€</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is called a <em>nominal set</em> when for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> has a finite, minimal support.</p>
<p>Nominal sets are the objects of a category (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math>) whose arrows are functions that preserve permutation
actions: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ€</mo><mi>Ï€</mi><mo>,</mo><mi>x</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mo>â‹…</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Ï€</mi><mo>â‹…</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\forall \pi, x. \; f(\pi \cdot x) = \pi \cdot f(x)</annotation></semantics></math>. These are called
<a href="https://en.wikipedia.org/wiki/Equivariant_map">equivariant</a> functions. One important fact about equivariant functions
is that theyâ€™re supported by the empty set (<a id="proof-14-link" href="nominal-sets-proofs#proof-14">A.14</a>).</p>
<p>The identity arrows are just the identity function on each nominal set. The identity function is
equivariant (<a id="proof-15-link" href="nominal-sets-proofs#proof-15">A.15</a>). Composition of arrows is the composition
of equivariant functions, which preserves equivariance
(<a id="proof-16-link" href="nominal-sets-proofs#proof-16">A.16</a>). Iâ€™ll use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><annotation encoding="application/x-tex">\rightarrow_{Nom}</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> arrows,
e.g.Â <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow_{Nom} Y</annotation></semantics></math>.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> has a <a href="https://en.wikipedia.org/wiki/Terminal_object">terminal object</a>, which is the
singleton set (<a id="proof-17-link" href="nominal-sets-proofs#proof-17">A.17</a>).</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> has <a href="https://en.wikipedia.org/wiki/Product_(category_theory)">products</a>, which
are pairs of nominal sets with an element-wise permutation action, because introduction and elimination of pairs is equivariant
(<a id="proof-18-link" href="nominal-sets-proofs#proof-18">A.18</a>).</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> has <a href="https://en.wikipedia.org/wiki/Coproduct">coproducts</a>, which is the normal
disjoint union on sets with an element-wise permutation action, because introduction and elimination of coproducts is equivariant
(<a id="proof-19-link" href="nominal-sets-proofs#proof-19">A.19</a>).</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> has <a href="https://en.wikipedia.org/wiki/Exponential_object">exponentials</a>, in the form of
finitely supported functions between nominal sets (<a id="proof-20-link" href="nominal-sets-proofs#proof-20">A.20</a>).</p>
<p>These facts have two important consequences for programmers:</p>
<ol type="1">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> is a <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">cartesian closed category</a>, which means it contains the lambda calculus. You can create a â€œnominal programming languageâ€ that has first class names<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> can express <a href="https://en.wikipedia.org/wiki/Initial_algebra">initial algebra semantics</a>, which means your â€œnominal programming languageâ€ can have â€œnominal algebraic datatypesâ€.</p></li>
</ol>
<p>In a sense <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> is fundamentally compatible with programming, and I think thatâ€™s why nominal sets are such a good inspiration for a library.</p>
<h3 id="some-adjunctions"><a href="#some-adjunctions">Some adjunctions</a></h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">[\mathbb{A}]({-})</annotation></semantics></math> is an endofunctor on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math> with the following action on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">Nom</mtext><annotation encoding="application/x-tex">\text{Nom}</annotation></semantics></math>-arrows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>Y</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
[\mathbb{A}](f) \; : \; [\mathbb{A}] X \rightarrow_{Nom} [\mathbb{A}] Y
\\
[\mathbb{A}](f)(\langle a \rangle x) = \langle a \rangle f(x)
\end{array}
</annotation></semantics></math></p>
<p>This means <code>Binder</code> has a <code>map</code> method:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> binder <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/** Correctness condition: `f` should not capture any [`Name`]s. When this is the case, we have `binder.map(f).map(g) == binder.map(|x| g(f(x)))`.</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> map<span class="op">&lt;</span>B<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> B) <span class="op">-&gt;</span> Binder<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">{</span> <span class="co">// (7)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>      Binder<span class="op">{</span> name<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>name<span class="op">,</span> body<span class="op">:</span> f(<span class="kw">self</span><span class="op">.</span>body) <span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">[\mathbb{A}]({-})</annotation></semantics></math> has left and right <a href="https://en.wikipedia.org/wiki/Adjoint_functors">adjoints</a> that induce a nice API for working with <code>Binder</code>s.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">[\mathbb{A}]({-})</annotation></semantics></math> is right adjoint to the functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow></mrow><mo>âˆ’</mo><mi>*</mi><mspace width="0.278em"></mspace><mi>ğ”¸</mi></mrow><annotation encoding="application/x-tex">{}- * \; \mathbb{A}</annotation></semantics></math> arising from the following
nominal set: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>*</mo><mi>ğ”¸</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><mi>x</mi><mo>âˆˆ</mo><mi>X</mi><mo>,</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>x</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">X * \mathbb{A} = \{ \; (x, a) \; | \; x \in X, a \; \# \; x  \;\}</annotation></semantics></math> (<a id="proof-22-link" href="nominal-sets-proofs#proof-22">A.22</a>).</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>X</mi><mo>*</mo><mi>ğ”¸</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi></mrow><mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>Y</mi></mrow></mfrac><annotation encoding="application/x-tex">
\frac{
X * \mathbb{A} \rightarrow_{Nom} Y
}{
X \rightarrow_{Nom} [\mathbb{A}] Y
}
</annotation></semantics></math></p>
<p><br></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">bind</mtext><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo>*</mo><mi>ğ”¸</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>Y</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">bind</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mtext mathvariant="normal">for some</mtext><mspace width="0.278em"></mspace><mi>a</mi><mi>#</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mspace width="0.278em"></mspace></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msup><mtext mathvariant="normal">bind</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mi>X</mi><mo>*</mo><mi>ğ”¸</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msup><mtext mathvariant="normal">bind</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi>ğ‘œ</mi><mi>ğ‘š</mi><mi>ğ‘–</mi><mi>ğ‘¡</mi><mi>ğ‘¡</mi><mi>ğ‘’</mi><mi>ğ‘‘</mi></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\text{bind} \; : \; (X * \mathbb{A} \rightarrow_{Nom} Y) \rightarrow
X \rightarrow_{Nom} [\mathbb{A}] Y
\\
\text{bind}(f)(x) = \langle a \rangle f(x, a) \;\;\; \text{for some} \; a \# x
\\ \; \\
\text{bind}^{-1} \; : \; (X \rightarrow_{Nom} [\mathbb{A}] Y) \rightarrow
X * \mathbb{A} \rightarrow_{Nom} Y
\\
\text{bind}^{-1}(f)(x) = \mathit{omitted}
\end{array}
</annotation></semantics></math></p>
<p>The â€œrightwardâ€ direction of the adjunction (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">bind</mtext><annotation encoding="application/x-tex">\text{bind}</annotation></semantics></math>) describes a way to create binders. It says that you can create a binder using a name that has never been seen before. This corresponds to the <code>bind</code> function from <a href="#names-and-binders">Names and Binders</a>.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">[\mathbb{A}]({-})</annotation></semantics></math> is left adjoint to this functor:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.278em"></mspace><mi>f</mi><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><mi>f</mi><mo>âˆˆ</mo><msup><mi>Y</mi><mi>ğ”¸</mi></msup><mo>,</mo><mspace width="0.278em"></mspace><mo>âˆ€</mo><mi>a</mi><mi>.</mi><mspace width="0.278em"></mspace><mi>a</mi><mspace width="0.278em"></mspace><mi>#</mi><mspace width="0.278em"></mspace><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">R(Y) = \{ \; f \; | \; f \in Y^{\mathbb{A}}, \; \forall a. \; a \; \# \; f(a) \;
\}</annotation></semantics></math> (<a id="proof-23-link" href="nominal-sets-proofs#proof-23">A.23</a>).</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi></mrow><mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><annotation encoding="application/x-tex">
\frac{
[\mathbb{A}] X \rightarrow_{Nom} Y
}{
X \rightarrow_{Nom} R(Y)
}
</annotation></semantics></math></p>
<p><br></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left" style="text-align: left"><msup><mtext mathvariant="normal">unbind</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msup><mtext mathvariant="normal">unbind</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mo>=</mo><mrow><mi>ğ‘œ</mi><mi>ğ‘š</mi><mi>ğ‘–</mi><mi>ğ‘¡</mi><mi>ğ‘¡</mi><mi>ğ‘’</mi><mi>ğ‘‘</mi></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mspace width="0.278em"></mspace></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">unbind</mtext><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>ğ”¸</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>X</mi><msub><mo>â†’</mo><mrow><mi>N</mi><mi>o</mi><mi>m</mi></mrow></msub><mi>Y</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">unbind</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>a</mi><mo stretchy="false" form="postfix">âŸ©</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{array}{l}
\text{unbind}^{-1} \; : \; ([\mathbb{A}] X \rightarrow_{Nom} Y) \rightarrow X \rightarrow_{Nom} R(Y)
\\
\text{unbind}^{-1} = \mathit{omitted}
\\ \; \\
\text{unbind} \; : \; (X \rightarrow_{Nom} R(Y)) \rightarrow [\mathbb{A}] X \rightarrow_{Nom} Y
\\
\text{unbind}(f)(\langle a \rangle x) = f(a)(x)
\end{array}
</annotation></semantics></math></p>
<p>The â€œleftwardâ€ direction of this adjunction (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">unbind</mtext><annotation encoding="application/x-tex">\text{unbind}</annotation></semantics></math>) describes how to consume binders.
You can consume a binder, accessing both its body and bound name, using a function that doesnâ€™t
â€œleakâ€ the name. This corresponds to <code>unbind</code> in <a href="#names-and-binders">Names and Binders</a>.</p>
<h2 id="showing-off"><a href="#showing-off">Showing off</a></h2>
<p>Having gone through the theoretical justifications for the design of the <code>Binder</code> type, letâ€™s examine
some of its benefits in practise.</p>
<h3 id="alpha-equivalence"><a href="#alpha-equivalence">Alpha equivalence</a></h3>
<p>Given implementations of <code>Permutable</code> and <code>Supported</code>, an abstract syntax tree can derive an <code>Eq</code>
instance that implements alpha equivalence:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>deriving<span class="at">(</span><span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Expr <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  Var(Name)<span class="op">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  Lam(Binder<span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;&gt;</span>)<span class="op">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  App(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Permutable <span class="cf">for</span> Expr <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> permute_by(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> permutation<span class="op">:</span> <span class="op">&amp;</span>Permutation) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Var(name) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Var(name<span class="op">.</span>permute_by(permutation))<span class="op">,</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Lam(binder) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(binder<span class="op">.</span>permute_by(permutation))<span class="op">,</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>App(left<span class="op">,</span> right) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        left<span class="op">.</span>permute_by(permutation)<span class="op">,</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        right<span class="op">.</span>permute_by(permutation)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Supported <span class="cf">for</span> Expr <span class="op">{</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> support(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> HashSet<span class="op">&lt;</span>Name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Var(name) <span class="op">=&gt;</span> <span class="pp">HashSet::</span>from([name])<span class="op">,</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Lam(binder) <span class="op">=&gt;</span> binder<span class="op">.</span>support()<span class="op">,</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>App(left<span class="op">,</span> right) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> support <span class="op">=</span> left<span class="op">.</span>support()<span class="op">;</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        support<span class="op">.</span>extend(right<span class="op">.</span>support())<span class="op">;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        support</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Which means the following are true:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// (\x -&gt; x) =_{alpha} (\y -&gt; y)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>x<span class="op">|</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(x))))<span class="op">,</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>y<span class="op">|</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(y))))</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">// (\x y -&gt; x) =_{alpha} (\y x -&gt; y)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>x<span class="op">|</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>Bind(<span class="op">|</span>y<span class="op">|</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(x))</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    ))))</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>y<span class="op">|</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>Bind(<span class="op">|</span>x<span class="op">|</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(y))</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    ))))</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co">// (\x y -&gt; x) !=_{alpha} (\x y -&gt; y)</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_neq!</span>(</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>x<span class="op">|</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>Bind(<span class="op">|</span>y<span class="op">|</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(x))</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    ))))</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>bind(<span class="op">|</span>x<span class="op">|</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Lam(<span class="pp">Binder::</span>Bind(<span class="op">|</span>y<span class="op">|</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Expr::</span>Var(y))</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    ))))</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<h3 id="capture-avoiding-substitution"><a href="#capture-avoiding-substitution">Capture-avoiding substitution</a></h3>
<p>Substituting a value for a name is defined by the <code>Subst</code> trait:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">mod</span> subst <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">trait</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;:</span> Permutable <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>V) <span class="op">-&gt;</span> <span class="dt">Self</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>It has all the usual implementations:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;,</span> B<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="cf">for</span> (A<span class="op">,</span> B) <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>V) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>subst(name<span class="op">,</span> value)<span class="op">,</span> <span class="kw">self</span><span class="op">.</span><span class="dv">1</span><span class="op">.</span>subst(name<span class="op">,</span> value))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>A<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;,</span> B<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="cf">for</span> <span class="pp">either::</span>Either<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>V) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">use</span> <span class="pp">either::</span>Either<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        Left(a) <span class="op">=&gt;</span> Left(a<span class="op">.</span>subst(name<span class="op">,</span> value))<span class="op">,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        Right(b) <span class="op">=&gt;</span> Right(b<span class="op">.</span>subst(name<span class="op">,</span> value))</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> </span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="cf">for</span> <span class="dt">Box</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>V) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Box</span><span class="pp">::</span>new(<span class="kw">self</span><span class="op">.</span>as_ref()<span class="op">.</span>subst(name<span class="op">,</span> value))</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>And the <code>Binder</code> implementation clones the binder before substituting into the body, which
guarantees capture-avoidance by binding a name that hasnâ€™t occurred in <code>name</code> or <code>value</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">use</span> <span class="kw">super</span><span class="pp">::binder::</span>Binder<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">impl</span> <span class="op">&lt;</span>T<span class="op">:</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> Subst<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="cf">for</span> Binder<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>V) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">self</span><span class="op">.</span>clone()<span class="op">.</span>map(<span class="op">|</span>body<span class="op">|</span> body<span class="op">.</span>subst(name<span class="op">,</span> value))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// mod subst</span></span></code></pre></div>
<p>Now capture-avoiding substitution can be defined for <code>Expr</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Subst<span class="op">&lt;</span>Expr<span class="op">&gt;</span> <span class="cf">for</span> Expr <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> subst(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> name<span class="op">:</span> <span class="op">&amp;</span>Name<span class="op">,</span> value<span class="op">:</span> <span class="op">&amp;</span>Expr) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Var(var) <span class="op">=&gt;</span> <span class="cf">if</span> var <span class="op">==</span> name <span class="op">{</span> </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        value<span class="op">.</span>clone()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Expr::</span>Var(var) </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">},</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>Lam(body) <span class="op">=&gt;</span> <span class="pp">Expr::</span>Lam(body<span class="op">.</span>subst(name<span class="op">,</span> value))<span class="op">,</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>      <span class="pp">Expr::</span>App(left<span class="op">,</span> right) <span class="op">=&gt;</span> <span class="pp">Expr::</span>App(</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        left<span class="op">.</span>subst(name<span class="op">,</span> value)<span class="op">,</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        right<span class="op">.</span>subst(name<span class="op">,</span> value)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="final-thoughts"><a href="#final-thoughts">Final thoughts</a></h2>
<p>While the library Iâ€™ve sketched so far is <em>okay</em>, itâ€™s not something Iâ€™d publish. Here are some outstanding issues, concerns, and questions:</p>
<ul>
<li><p>I donâ€™t like the lack of support for mutability. Functions like <code>permute_by</code> and
<code>subst</code> end up rebuilding the value theyâ€™re acting on. This is a waste of time when I have exclusive
access to the value; I should be able to mutate the value in place and skip â€œreconstructingâ€ the result.</p></li>
<li><p>The implementation of <code>PartialEq</code> for <code>Binder</code> is wasteful:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> eq(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">use</span> <span class="kw">super</span><span class="pp">::name::</span>fresh<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b <span class="op">=</span> fresh()<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">self</span><span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(<span class="kw">self</span><span class="op">.</span>name<span class="op">,</span> b)) <span class="op">==</span> </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      other<span class="op">.</span>permute_by(<span class="pp">Permutation::</span>swap(other<span class="op">.</span>name<span class="op">,</span> b))</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function (immutably) permutes each argument, which amounts to cloning them. I should be able to
compare binders without cloning! Whatâ€™s more, the structure is essentially walked from root to tip
once for each binder it contains. Comparison should be done a <em>single</em> downward pass.</p></li>
<li><p><code>Permutable</code>, <code>Supported</code>, and <code>Subst</code> for user-defined types are boilerplate. They should be automatically derived, or based on a single user-defined function that locates names in the userâ€™s datatypes.</p></li>
<li><p>Should <code>Eq</code> actually implement alpha equivalence, or should I have a separate trait? Iâ€™m not sure how to implement <code>Eq</code> efficiently given its signature, and my intuition suggests <code>Eq</code> should be strict structural equality rather than including any quotienting.</p></li>
<li><p>Should the user be able to choose different <code>fresh</code> functions? This doesnâ€™t really matter if <code>Eq</code> implements alpha equivalence, but if <code>Eq</code> is structural equivalence then it might be more convenient to use a different â€œname generatorâ€ for testing.</p></li>
</ul>
<p>You can follow my explorations at <a href="https://github.com/LightAndLight/binders.rs" class="uri">https://github.com/LightAndLight/binders.rs</a>.</p>
<h2 id="appendix-a-proofs"><a href="#appendix-a-proofs">Appendix A: Proofs</a></h2>
<p>See <a href="./nominal-sets-proofs">Nominal Sets: Appendix A (Proofs)</a>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Let me know if (when?) Iâ€™m wrong about this!<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>Pitts, A. M. (2013). Nominal sets: Names and symmetry in computer science.
Cambridge University Press.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>Pitts, A. M. (2003). Nominal logic, a first order theory of names and binding.
Information and computation, 186(2), 165-193.</p>
<p><a href="https://doi.org/10.1016/S0890-5401(03)00138-X" class="uri">https://doi.org/10.1016/S0890-5401(03)00138-X</a><a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p>Pitts, A. M. (2006). Alpha-structural recursion and
induction. Journal of the ACM (JACM), 53(3), 459-506.</p>
<p><a href="https://doi.org/10.1145/1147954.1147961" class="uri">https://doi.org/10.1145/1147954.1147961</a><a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn5"><p>Pitts, A. (2016). Nominal techniques. ACM SIGLOG News, 3(1), 57-72.</p>
<p><a href="https://doi.org/10.1145/2893582.2893594" class="uri">https://doi.org/10.1145/2893582.2893594</a><a href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn6"><p>I found <a href="https://www.hedonisticlearning.com/posts/quotient-types-for-programmers.html">â€œQuotient Types for
Programmersâ€</a> very
helpful for understanding quotients.<a href="#fnref6" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn7"><p>Cheney, J. (2009). A simple nominal type theory. Electronic Notes
in Theoretical Computer Science, 228, 37-52.</p>
<p><a href="https://doi.org/10.1016/j.entcs.2008.12.115" class="uri">https://doi.org/10.1016/j.entcs.2008.12.115</a><a href="#fnref7" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>
  <p class="post-navigation">
    
    <a href="/nominal-sets-proofs" title="Previous post: Nominal Sets: Appendix A (Proofs)">â† Nominal Sets: Appendix A (Proofs)</a>
    

    
    <a href="/diablo-1-in-2023" title="Next post: Diablo 1 in 2023">Diablo 1 in 2023 â†’</a>
    
  </p>
</article>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'ielliott'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
  </main>

  <footer>
    <span>Isaac Elliott</span>

    <ol>
      <li><a class="footer-item-link" href="https://github.com/lightandlight">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M208.31 75.68A59.78 59.78 0 0 0 202.93 28a8 8 0 0 0-6.93-4 59.75 59.75 0 0 0-48 24h-24a59.75 59.75 0 0 0-48-24 8 8 0 0 0-6.93 4 59.78 59.78 0 0 0-5.38 47.68A58.14 58.14 0 0 0 56 104v8a56.06 56.06 0 0 0 48.44 55.47A39.8 39.8 0 0 0 96 192v8H72a24 24 0 0 1-24-24 40 40 0 0 0-40-40 8 8 0 0 0 0 16 24 24 0 0 1 24 24 40 40 0 0 0 40 40h24v16a8 8 0 0 0 16 0v-40a24 24 0 0 1 48 0v40a8 8 0 0 0 16 0v-40a39.8 39.8 0 0 0-8.44-24.53A56.06 56.06 0 0 0 216 112v-8a58.14 58.14 0 0 0-7.69-28.32M200 112a40 40 0 0 1-40 40h-48a40 40 0 0 1-40-40v-8a41.74 41.74 0 0 1 6.9-22.48 8 8 0 0 0 1.1-7.69 43.8 43.8 0 0 1 .79-33.58 43.88 43.88 0 0 1 32.32 20.06 8 8 0 0 0 6.71 3.69h32.35a8 8 0 0 0 6.74-3.69 43.87 43.87 0 0 1 32.32-20.06 43.8 43.8 0 0 1 .77 33.58 8.09 8.09 0 0 0 1 7.65 41.7 41.7 0 0 1 7 22.52Z"></path></svg>
        GitHub
      </a>

      <li><a class="footer-item-link" href="mailto:blog@id.ielliott.io">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 48H32a8 8 0 0 0-8 8v136a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a8 8 0 0 0-8-8m-20.57 16L128 133.15 52.57 64ZM216 192H40V74.19l82.59 75.71a8 8 0 0 0 10.82 0L216 74.19z"></path></svg>
        Email
      </a>

      <li><a class="footer-item-link" href="https://blog.ielliott.io/feed.xml">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 192a8 8 0 0 1-16 0c0-79.4-64.6-144-144-144a8 8 0 0 1 0-16c88.22 0 160 71.78 160 160M64 104a8 8 0 0 0 0 16 72.08 72.08 0 0 1 72 72 8 8 0 0 0 16 0 88.1 88.1 0 0 0-88-88m4 72a12 12 0 1 0 12 12 12 12 0 0 0-12-12"></path></svg>
        Feed
      </a>
    </ol>
  </footer>

  
</body>

</html>