<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/fonts/SourceSerif4/SourceSerif4-Regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/SourceSans3/SourceSans3-Regular.woff2" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href="/res/fonts.css">
  <link rel="stylesheet" href="/res/style.css">

  <!-- defer non-critical stylesheet -->
  <link href="/res/syntax.css" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/res/syntax.css"></noscript>

  

  

  

  
  <title>Comonad Transformers in the Wild - blog.ielliott.io</title>
  

  <link rel="canonical" href="https://blog.ielliott.io/comonad-transformers-in-the-wild">
<link rel="alternate" type="application/atom+xml" title="blog.ielliott.io" href="/feed.xml">

<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="blog.ielliott.io">
<meta property="og:url" content="https://blog.ielliott.io/comonad-transformers-in-the-wild">
<meta property="og:title" content="Comonad Transformers in the Wild">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Comonad Transformers in the Wild">


<meta name="author" content="Isaac Elliott">
<meta name="description" content="A certain algorithmic puzzle website has a problem that goes like this...">
<meta property="og:description" content="A certain algorithmic puzzle website has a problem that goes like this...">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-02-25T00:00+00:00">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline":"Comonad Transformers in the Wild",
  "author": {
    "@type":"Person",
    "name":"Isaac Elliott"
  },
  "datePublished":"2018-02-25T00:00+00:00",
  "dateModified":"2018-02-25T00:00+00:00",
  "description":"A certain algorithmic puzzle website has a problem that goes like this...",
  "mainEntityOfPage": {
    "@type":"WebPage",
    "@id":"https://blog.ielliott.io/comonad-transformers-in-the-wild"
  },
  "url": "https://blog.ielliott.io/comonad-transformers-in-the-wild"
}
</script>
</head>

<body>
  <header>
    <h1><a href="/">I E</a></h1>
    <nav>
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/about">About</a>
        <li><a href="/resources">Resources</a>
      </ol>
    </nav>
  </header>

  <main>
    

    <article>
  <header>
    <h1>Comonad Transformers in the Wild</h1>
    <p class="post-metadata">
      25 February, 2018
      
      ⋅
      
<a class="post-metadata-tag" href="/tags/programming">programming</a>

<a class="post-metadata-tag" href="/tags/haskell">haskell</a>


      
    </p>
  </header>
  <p>A certain algorithmic puzzle website has a problem that goes like this…</p>
<pre><code>Given a grid of integers, find the largest product of n numbers which are
adjacent in the same direction (left, right, up, down, or diagonally)</code></pre>
<p>In this diagram, <code>A</code>, <code>B</code>, and <code>C</code> are diagonally adjacent:</p>
<pre><code>0 0 0 0
0 0 0 C
0 0 B 0
0 A 0 0 </code></pre>
<p>And in this one, <code>A</code>, <code>B</code>, and <code>C</code> are vertically adjacent:</p>
<pre><code>0 A 0 0
0 B 0 0
0 C 0 0
0 0 0 0 </code></pre>
<p>I initially solved the problem with this data structure and operations:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Grid</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Grid</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> width ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> height ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> xPos ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> yPos ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> content ::</span> [[a]]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ot">focus ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>focus (<span class="dt">Grid</span> _ _ x y g) <span class="ot">=</span> (g <span class="op">!!</span> y) <span class="op">!!</span> x</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- These operations return Nothing if we are at the edge of the grid,</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- otherwise increment/decrement xPos/yPos accordingly</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>up, left, down,<span class="ot"> right ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span></code></pre></div>
<p>The idea being to walk through the grid, and for each position calculate the product of the adjacent elements. For example, the product of the focus and the two neighbours to its right would be:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>example1 grid <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  (\b c <span class="ot">-&gt;</span> focus grid <span class="op">*</span> b <span class="op">*</span> c) <span class="op">&lt;$&gt;</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> pos (right grid) <span class="op">&lt;*&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> pos (right <span class="op">&lt;=&lt;</span> right <span class="op">$</span> grid)</span></code></pre></div>
<p><code>Grid</code> can be given a <code>Comonad</code> instance, and this process of per-position calulation can be expressed using comonadic operations. If we plug the <code>example1</code> function into <code>extend</code>, we get the function <code>extend example1 :: Grid a -&gt; Grid (Maybe a)</code>. This function walks through the grid, and replaces each cell with the result of running <code>example1</code> on it and its neighbours.</p>
<p>This is cool in and of itself, but implementing <code>duplicate</code> or <code>extend</code> for <code>Grid</code> is tedious. <code>Grid</code> can actually be implemented as the composition of two comonads: <a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Env.html">Env</a> and <a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Store.html">Store</a>, which gives us the correct comonadic behaviour for free.</p>
<hr />
<p><a href="../files/grid_comonad.lhs">Literal Haskell source</a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (liftA2)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> ((&lt;=&lt;))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Comonad</span> ((=&gt;&gt;), extract)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Comonad.Env</span> (<span class="dt">EnvT</span>(..), ask)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Comonad.Store</span> (<span class="dt">Store</span>, store, peek, pos, seek)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (maximum)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Dimensions</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Position</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Grid</span> a <span class="ot">=</span> <span class="dt">EnvT</span> <span class="dt">Dimensions</span> (<span class="dt">Store</span> <span class="dt">Position</span>) a</span></code></pre></div>
<p><code>EnvT e w a</code> is an environment of type <code>e</code> paired with an underlying comonad <code>w a</code>. We can inspect the environment with <code>ask :: ComonadEnv e w =&gt; w a -&gt; e</code>. <code>extract</code>ing from an <code>EnvT</code> just extracts from the underlying comonad, and ignores the environment. The dimensions of the grid are the environment because they remain static throughout the program.</p>
<p><code>Store s a</code> consists of some state <code>s</code>, and an “accessor” function of type <code>s -&gt; a</code>. <code>extract</code>ing a <code>Store</code> feeds its state into the accessor function. For <code>Grid</code>, the focus position is the state, and the accessor is a function that pulls out the corresponding element from some list of lists.</p>
<p>Three important functions on <code>Store</code> are:</p>
<ul>
<li><code>pos :: ComonadStore s w =&gt; w a -&gt; s</code></li>
<li><code>seek :: ComonadStore s w =&gt; s -&gt; w a -&gt; w a</code></li>
<li><code>peek :: ComonadStore s w =&gt; s -&gt; w a -&gt; a</code></li>
</ul>
<p><code>pos</code> returns the current state, <code>seek</code> replaces the state, and <code>peek</code> runs the accessor function on a different piece of state, leaving the actual state unchanged.</p>
<p>Here’s how we make a grid. Notice that the accessor function passed to <code>store</code> behaves like <code>focus</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkGrid ::</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>mkGrid [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>mkGrid g<span class="op">@</span>(r<span class="op">:</span>rs)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> rl <span class="ot">&lt;-</span> <span class="fu">length</span> r</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  , <span class="fu">all</span> ((<span class="op">==</span>rl) <span class="op">.</span> <span class="fu">length</span>) rs <span class="ot">=</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> <span class="op">$</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">EnvT</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        (rl, <span class="fu">length</span> g)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        (store (\(x, y) <span class="ot">-&gt;</span> (g <span class="op">!!</span> y) <span class="op">!!</span> x) (<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>If the grid has no rows, or has rows of different lengths, return nothing. Otherwise, calculate the dimensions of the grid, and initialise the store pointing to the top-left cell in the grid.</p>
<p>Now we can implement <code>up, down, left, right</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">up ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>up g <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    (w, h) <span class="ot">=</span> ask g</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">=</span> pos g</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> y <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Just</span> (seek (x, y<span class="op">-</span><span class="dv">1</span>) g) <span class="kw">else</span> <span class="dt">Nothing</span> </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">left ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>left g <span class="ot">=</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    (w, h) <span class="ot">=</span> ask g</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">=</span> pos g</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Just</span> (seek (x<span class="op">-</span><span class="dv">1</span>, y) g) <span class="kw">else</span> <span class="dt">Nothing</span> </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ot">down ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>down g <span class="ot">=</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    (w, h) <span class="ot">=</span> ask g</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">=</span> pos g</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> y <span class="op">&lt;</span> h<span class="op">-</span><span class="dv">1</span> <span class="kw">then</span> <span class="dt">Just</span> (seek (x, y<span class="op">+</span><span class="dv">1</span>) g) <span class="kw">else</span> <span class="dt">Nothing</span> </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="ot">right ::</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>right g <span class="ot">=</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    (w, h) <span class="ot">=</span> ask g</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">=</span> pos g</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> x <span class="op">&lt;</span> w<span class="op">-</span><span class="dv">1</span> <span class="kw">then</span> <span class="dt">Just</span> (seek (x<span class="op">+</span><span class="dv">1</span>, y) g) <span class="kw">else</span> <span class="dt">Nothing</span> </span></code></pre></div>
<p>Next are some helper functions for calculating the product of a grid element and its neighbours.</p>
<p><code>iterateM</code> is the monadic equivalent of <a href="https://hackage.haskell.org/package/base/docs/Data-List.html#v:iterate">iterate</a>.</p>
<p><code>productN</code> calculates the product of the current grid element with its adjacent neighbours in some direction. <code>example1</code> could be redefined as <code>productN 3 right</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iterateM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> [a <span class="ot">-&gt;</span> m a]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>iterateM f <span class="ot">=</span> f <span class="op">:</span> <span class="fu">fmap</span> (f <span class="op">&lt;=&lt;</span>) (iterateM f)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">productN ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Grid</span> a)) <span class="ot">-&gt;</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>productN n f g <span class="ot">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    (\a b <span class="ot">-&gt;</span> liftA2 (<span class="op">*</span>) (extract <span class="op">&lt;$&gt;</span> a g) b)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">pure</span> <span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">take</span> n <span class="op">$</span> iterateM f)</span></code></pre></div>
<p>Penultimately, we define a function for finding the greatest element in a grid. It <code>peek</code>s at all the elements and finds the greatest one.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxInGrid ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Grid</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>maxInGrid g <span class="ot">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    (w, h) <span class="ot">=</span> ask g</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">maximum</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>w<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>      y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>h<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> peek (x, y) g</span></code></pre></div>
<p>Last step. To find the largest product of <code>n</code> adjacent elements, we find the largest product of <code>n</code> adjacent elements horizontally, then vertically, then diagonally, and take the maximum of those.</p>
<p>We can write this logic as a series of <code>extend</code>s, because <code>productN n move</code> and <code>maxInGrid</code> are both of the form <code>w a -&gt; b</code>. (<code>(=&gt;&gt;)</code> is the flipped infix version of <code>extend</code>)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">largestProduct ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>largestProduct n g <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> g1 <span class="ot">=</span> extract <span class="op">$</span> g <span class="op">=&gt;&gt;</span> productN n right            <span class="op">=&gt;&gt;</span> maxInGrid</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> g2 <span class="ot">=</span> extract <span class="op">$</span> g <span class="op">=&gt;&gt;</span> productN n down             <span class="op">=&gt;&gt;</span> maxInGrid</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> g3 <span class="ot">=</span> extract <span class="op">$</span> g <span class="op">=&gt;&gt;</span> productN n (down <span class="op">&lt;=&lt;</span> left)  <span class="op">=&gt;&gt;</span> maxInGrid</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> g4 <span class="ot">=</span> extract <span class="op">$</span> g <span class="op">=&gt;&gt;</span> productN n (down <span class="op">&lt;=&lt;</span> right) <span class="op">=&gt;&gt;</span> maxInGrid</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">maximum</span> [g1, g2, g3, g4]</span></code></pre></div>
<p>I’m still getting an intuition for comonads, but they seem to embody some kind of “environment”, and comonad transformers are like a “composition of environments”. In this example, there are two environments: the grid’s dimensions, and its content.</p>
<p>For more information about comonads, check out Bartosz Milewski’s <a href="https://bartoszmilewski.com/2017/01/02/comonads/">comonads post</a> and Dan Piponi’s article about <a href="http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html">comonadic cellular automata</a>.</p>
<p>Footnote: I feel like <code>largestProduct</code> could be simplified if <code>Grid</code> were <code>ComonadApply</code>, but I haven’t tried to figure it out yet.</p>
  <p class="post-navigation">
    
    <a href="/continuations-from-the-ground-up" title="Previous post: Continuations From the Ground Up">← Continuations From the Ground Up</a>
    

    
    <a href="/topsy-turvy-reverse-state" title="Next post: Turning bottom-up into top-down with Reverse State">Turning bottom-up into top-down with Reverse State →</a>
    
  </p>
</article>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'ielliott'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
  </main>

  <footer>
    <span>Isaac Elliott</span>

    <ol>
      <li><a class="footer-item-link" href="https://github.com/lightandlight">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M208.31 75.68A59.78 59.78 0 0 0 202.93 28a8 8 0 0 0-6.93-4 59.75 59.75 0 0 0-48 24h-24a59.75 59.75 0 0 0-48-24 8 8 0 0 0-6.93 4 59.78 59.78 0 0 0-5.38 47.68A58.14 58.14 0 0 0 56 104v8a56.06 56.06 0 0 0 48.44 55.47A39.8 39.8 0 0 0 96 192v8H72a24 24 0 0 1-24-24 40 40 0 0 0-40-40 8 8 0 0 0 0 16 24 24 0 0 1 24 24 40 40 0 0 0 40 40h24v16a8 8 0 0 0 16 0v-40a24 24 0 0 1 48 0v40a8 8 0 0 0 16 0v-40a39.8 39.8 0 0 0-8.44-24.53A56.06 56.06 0 0 0 216 112v-8a58.14 58.14 0 0 0-7.69-28.32M200 112a40 40 0 0 1-40 40h-48a40 40 0 0 1-40-40v-8a41.74 41.74 0 0 1 6.9-22.48 8 8 0 0 0 1.1-7.69 43.8 43.8 0 0 1 .79-33.58 43.88 43.88 0 0 1 32.32 20.06 8 8 0 0 0 6.71 3.69h32.35a8 8 0 0 0 6.74-3.69 43.87 43.87 0 0 1 32.32-20.06 43.8 43.8 0 0 1 .77 33.58 8.09 8.09 0 0 0 1 7.65 41.7 41.7 0 0 1 7 22.52Z"></path></svg>
        GitHub
      </a>

      <li><a class="footer-item-link" href="mailto:blog@id.ielliott.io">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 48H32a8 8 0 0 0-8 8v136a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a8 8 0 0 0-8-8m-20.57 16L128 133.15 52.57 64ZM216 192H40V74.19l82.59 75.71a8 8 0 0 0 10.82 0L216 74.19z"></path></svg>
        Email
      </a>

      <li><a class="footer-item-link" href="https://blog.ielliott.io/feed.xml">
        <svg class="footer-item-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M224 192a8 8 0 0 1-16 0c0-79.4-64.6-144-144-144a8 8 0 0 1 0-16c88.22 0 160 71.78 160 160M64 104a8 8 0 0 0 0 16 72.08 72.08 0 0 1 72 72 8 8 0 0 0 16 0 88.1 88.1 0 0 0-88-88m4 72a12 12 0 1 0 12 12 12 12 0 0 0-12-12"></path></svg>
        Feed
      </a>
    </ol>
  </footer>

  
</body>

</html>